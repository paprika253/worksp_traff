<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.2">
<meta name="author" content="Mark Paluch">
<title>Lettuce Reference Guide</title>
<link rel="stylesheet" href="stylesheets/golo.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="icon" type="image/png" href="images/apple-touch-icon-144.png"/>
<link rel="apple-touch-icon-precomposed" sizes="180x180" href="images/apple-touch-icon-180.png">
<link rel="shortcut icon" href="images/touch-icon-192x192.png">
<meta name="msapplication-TileImage" content="images/apple-touch-icon-144.png">
<link rel="icon" sizes="192x192" href="images/touch-icon-192x192.png">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Lettuce Reference Guide</h1>
<div class="details">
<span id="author" class="author">Mark Paluch</span><br>
<span id="email" class="email"><a href="https://twitter.com/mp911de">@mp911de</a></span><br>
<span id="revdate">5.2.2.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#overview.redis">1.1. Knowing Redis</a></li>
<li><a href="#_project_reactor">1.2. Project Reactor</a></li>
<li><a href="#_non_blocking_api_for_redis">1.3. Non-blocking API for Redis</a></li>
<li><a href="#overview.requirements">1.4. Requirements</a></li>
<li><a href="#_additional_help_resources">1.5. Additional Help Resources</a>
<ul class="sectlevel3">
<li><a href="#overview.support">1.5.1. Support</a></li>
<li><a href="#overview.development">1.5.2. Following Development</a></li>
<li><a href="#_project_metadata">1.5.3. Project Metadata</a></li>
</ul>
</li>
<li><a href="#_where_to_go_from_here">1.6. Where to go from here</a></li>
</ul>
</li>
<li><a href="#new-features">2. New &amp; Noteworthy</a>
<ul class="sectlevel2">
<li><a href="#new-features.5-2-0">2.1. What&#8217;s new in Lettuce 5.2</a></li>
<li><a href="#new-features.5-1-0">2.2. What&#8217;s new in Lettuce 5.1</a></li>
<li><a href="#new-features.5-0-0">2.3. What&#8217;s new in Lettuce 5.0</a></li>
</ul>
</li>
<li><a href="#getting-started">3. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#getting-started.get-it">3.1. 1. Get it</a>
<ul class="sectlevel3">
<li><a href="#_for_maven_users">3.1.1. For Maven users:</a></li>
<li><a href="#_for_ivy_users">3.1.2. For Ivy users:</a></li>
<li><a href="#_for_gradle_users">3.1.3. For Gradle users:</a></li>
<li><a href="#getting-started.plain-java">3.1.4. Plain Java</a></li>
</ul>
</li>
<li><a href="#getting-started.start-coding">3.2. 2. Start coding</a></li>
</ul>
</li>
<li><a href="#connecting-redis">4. Connecting Redis</a>
<ul class="sectlevel2">
<li><a href="#redisuri.uri-syntax">4.1. URI syntax</a></li>
<li><a href="#basic-usage">4.2. Basic Usage</a>
<ul class="sectlevel3">
<li><a href="#basic.redisuri">4.2.1. RedisURI</a></li>
<li><a href="#basic.exceptions">4.2.2. Exceptions</a></li>
<li><a href="#basic.examples">4.2.3. Examples</a></li>
</ul>
</li>
<li><a href="#asynchronous-api">4.3. Asynchronous API</a>
<ul class="sectlevel3">
<li><a href="#asynchronous-api.motivation">4.3.1. Motivation</a></li>
<li><a href="#asynchronous-api.creating-futures-using-lettuce">4.3.2. Creating futures using lettuce</a></li>
<li><a href="#asynchronous-api.consuming-futures">4.3.3. Consuming futures</a></li>
<li><a href="#asynchronous-api.synchronizing-futures">4.3.4. Synchronizing futures</a></li>
<li><a href="#asynchronous-api.error-handling">4.3.5. Error handling</a></li>
<li><a href="#asynchronous-api.examples">4.3.6. Examples</a></li>
</ul>
</li>
<li><a href="#reactive-api">4.4. Reactive API</a>
<ul class="sectlevel3">
<li><a href="#reactive.5.motivation">4.4.1. Motivation</a></li>
<li><a href="#reactive.5.understanding-reactive-streams">4.4.2. Understanding Reactive Streams</a></li>
<li><a href="#reactive.5.understanding-publishers">4.4.3. Understanding Publishers</a></li>
<li><a href="#reactive.5.a-word-on-the-lettuce-reactive-api">4.4.4. A word on the lettuce Reactive API</a></li>
<li><a href="#reactive.5.consuming-publisher">4.4.5. Consuming <code>Publisher&lt;T&gt;</code></a></li>
<li><a href="#reactive.5.from-push-to-pull">4.4.6. From push to pull</a></li>
<li><a href="#reactive.5.creating-flux-and-mono-using-lettuce">4.4.7. Creating <code>Flux</code> and <code>Mono</code> using lettuce</a></li>
<li><a href="#reactive.5.hot-and-cold-publishers">4.4.8. Hot and Cold Publishers</a></li>
<li><a href="#reactive.5.transforming-publishers">4.4.9. Transforming publishers</a></li>
<li><a href="#reactive.5.absent-values">4.4.10. Absent values</a></li>
<li><a href="#reactive.5.filtering-items">4.4.11. Filtering items</a></li>
<li><a href="#reactive.5.error-handling">4.4.12. Error handling</a></li>
<li><a href="#reactive.5.schedulers-and-threads">4.4.13. Schedulers and threads</a></li>
<li><a href="#reactive.5.redis-transactions">4.4.14. Redis Transactions</a></li>
</ul>
</li>
<li><a href="#_publishsubscribe">4.5. Publish/Subscribe</a>
<ul class="sectlevel3">
<li><a href="#pubsub.subscribing">4.5.1. Subscribing</a></li>
<li><a href="#pubsub.reactive-api">4.5.2. Reactive API</a></li>
<li><a href="#pubsub.cluster">4.5.3. Redis Cluster</a></li>
</ul>
</li>
<li><a href="#_transactionsmulti">4.6. Transactions/Multi</a>
<ul class="sectlevel3">
<li><a href="#transactions-using-the-asynchronous-api">4.6.1. Transactions using the asynchronous API</a></li>
<li><a href="#transactions-using-the-reactive-api">4.6.2. Transactions using the reactive API</a></li>
<li><a href="#transactions-on-clustered-connections">4.6.3. Transactions on clustered connections</a></li>
<li><a href="#examples">4.6.4. Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ha-sharding">5. High-Availability and Sharding</a>
<ul class="sectlevel2">
<li><a href="#master-replica">5.1. Master/Replica</a>
<ul class="sectlevel3">
<li><a href="#masterreplica.redis-sentinel">5.1.1. Redis Sentinel</a></li>
<li><a href="#masterreplica.standalone-masterreplica">5.1.2. Standalone Master/Replica</a></li>
<li><a href="#masterreplica.static-masterreplica-with-predefined-node-addresses">5.1.3. Static Master/Replica with predefined node addresses</a></li>
<li><a href="#masterreplica.topology-discovery">5.1.4. Topology discovery</a></li>
<li><a href="#masterreplica.topology-updates">5.1.5. Topology Updates</a></li>
</ul>
</li>
<li><a href="#redis-sentinel">5.2. Redis Sentinel</a>
<ul class="sectlevel3">
<li><a href="#direct-connection-redis-sentinel-nodes">5.2.1. Direct connection Redis Sentinel nodes</a></li>
<li><a href="#sentinel.redis-discovery-using-redis-sentinel">5.2.2. Redis discovery using Redis Sentinel</a></li>
<li><a href="#sentinel.examples">5.2.3. Examples</a></li>
</ul>
</li>
<li><a href="#redis-cluster">5.3. Redis Cluster</a>
<ul class="sectlevel3">
<li><a href="#redis-cluster.command-routing">5.3.1. Command routing</a></li>
<li><a href="#redis-cluster.cross-slot-command-routing">5.3.2. Cross-slot command execution and cluster-wide execution for selected commands</a></li>
<li><a href="#redis-cluster.execution-of-commands-on-one-or-multiple-cluster-nodes">5.3.3. Execution of commands on one or multiple cluster nodes</a></li>
<li><a href="#redis-cluster.refreshing-the-cluster-topology-view">5.3.4. Refreshing the cluster topology view</a></li>
<li><a href="#redis-cluster.connection-count">5.3.5. Connection Count for a Redis Cluster Connection Object</a></li>
<li><a href="#redis-cluster.client-options">5.3.6. Client-options</a></li>
</ul>
</li>
<li><a href="#readfrom-settings">5.4. ReadFrom Settings</a>
<ul class="sectlevel3">
<li><a href="#readfrom.redis-cluster">5.4.1. Redis Cluster</a></li>
<li><a href="#readfrom.masterreplica-connections">5.4.2. Master/Replica connections</a></li>
<li><a href="#readfrom.use-cases-for-non-master-reads">5.4.3. Use Cases for non-master reads</a></li>
<li><a href="#readfrom.read-from-settings">5.4.4. Read from settings</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis-command-interfaces">6. Working with dynamic Redis Command Interfaces</a>
<ul class="sectlevel2">
<li><a href="#_introduction">6.1. Introduction</a></li>
<li><a href="#_command_methods">6.2. Command methods</a></li>
<li><a href="#_defining_command_methods">6.3. Defining command methods</a>
<ul class="sectlevel3">
<li><a href="#_command_naming">6.3.1. Command naming</a></li>
<li><a href="#_camelcase_in_method_names">6.3.2. CamelCase in method names</a></li>
<li><a href="#_command_annotation">6.3.3. <code>@Command</code> annotation</a></li>
<li><a href="#command-interfaces.parameters">6.3.4. Parameters</a></li>
<li><a href="#_codecs">6.3.5. Codecs</a></li>
<li><a href="#command-interfaces.response-types">6.3.6. Response types</a></li>
</ul>
</li>
<li><a href="#command-interfaces.execution-models">6.4. Execution models</a>
<ul class="sectlevel3">
<li><a href="#command-interfaces.synchronous">6.4.1. Synchronous (Blocking) Execution</a></li>
<li><a href="#command-interfaces.asynchronous">6.4.2. Asynchronous (Future) Execution</a></li>
<li><a href="#command-interfaces.reactive">6.4.3. Reactive Execution</a></li>
<li><a href="#command-interfaces.batch">6.4.4. Batch Execution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced-usage">7. Advanced usage</a>
<ul class="sectlevel2">
<li><a href="#client-resources">7.1. Configuring Client resources</a>
<ul class="sectlevel3">
<li><a href="#clientresources.creating-client-resources">7.1.1. Creating Client resources</a></li>
<li><a href="#clientresources.using-and-reusing-clientresources">7.1.2. Using and reusing <code>ClientResources</code></a></li>
<li><a href="#clientresources.configuration-settings">7.1.3. Configuration settings</a></li>
<li><a href="#clientresources.advanced-settings">7.1.4. Advanced settings</a></li>
</ul>
</li>
<li><a href="#client-options">7.2. Client Options</a>
<ul class="sectlevel3">
<li><a href="#clientoptions.cluster-specific-options">7.2.1. Cluster-specific options</a></li>
<li><a href="#clientoptions.request-queue-size-and-cluster">7.2.2. Request queue size and cluster</a></li>
</ul>
</li>
<li><a href="#ssl">7.3. SSL Connections</a>
<ul class="sectlevel3">
<li><a href="#ssl.limitations">7.3.1. Limitations</a></li>
<li><a href="#ssl.connection-procedure-and-reconnect">7.3.2. Connection Procedure and Reconnect</a></li>
<li><a href="#ssl.certificate-chainsroot-certificateself-signed-certificates">7.3.3. Certificate Chains/Root Certificate/Self-Signed Certificates</a></li>
<li><a href="#ssl.hostpeer-verification">7.3.4. Host/Peer Verification</a></li>
<li><a href="#starttls">7.3.5. StartTLS</a></li>
</ul>
</li>
<li><a href="#native-transports">7.4. Native Transports</a>
<ul class="sectlevel3">
<li><a href="#unixdomainsockets.limitations">7.4.1. Limitations</a></li>
</ul>
</li>
<li><a href="#unix-domain-sockets">7.5. Unix Domain Sockets</a></li>
<li><a href="#streaming-api">7.6. Streaming API</a>
<ul class="sectlevel3">
<li><a href="#streaming.examples">7.6.1. Examples</a></li>
</ul>
</li>
<li><a href="#events">7.7. Events</a>
<ul class="sectlevel3">
<li><a href="#events.before-3.44.1">7.7.1. Before 3.4/4.1</a></li>
<li><a href="#events.since-3.44.1">7.7.2. Since 3.4/4.1</a></li>
</ul>
</li>
<li><a href="#_pipelining_and_command_flushing">7.8. Pipelining and command flushing</a>
<ul class="sectlevel3">
<li><a href="#pipelining.command-flushing">7.8.1. Command flushing</a></li>
</ul>
</li>
<li><a href="#_connection_pooling">7.9. Connection Pooling</a>
<ul class="sectlevel3">
<li><a href="#connection-pooling.is-connection-pooling-necessary">7.9.1. Is connection pooling necessary?</a></li>
<li><a href="#connection-pooling.modes">7.9.2. Execution Models</a></li>
<li><a href="#connection-pooling.blocking">7.9.3. Synchronous Connection Pooling</a></li>
<li><a href="#connection-pooling.asynchronous.usage">7.9.4. Asynchronous Connection Pooling</a></li>
</ul>
</li>
<li><a href="#_custom_commands">7.10. Custom commands</a>
<ul class="sectlevel3">
<li><a href="#custom-commands.mechanics-of-lettuce-commands">7.10.1. Mechanics of Lettuce commands</a></li>
<li><a href="#custom-commands.synchronous-asynchronous-and-reactive">7.10.2. Synchronous, asynchronous and reactive</a></li>
</ul>
</li>
<li><a href="#command-execution-reliability">7.11. Command execution reliability</a>
<ul class="sectlevel3">
<li><a href="#command-execution-reliability.general">7.11.1. General</a></li>
<li><a href="#command-execution-reliability.what-does-at-most-once-mean">7.11.2. What does <em>at-most-once</em> mean?</a></li>
<li><a href="#command-execution-reliability.why-no-guaranteed-delivery">7.11.3. Why No Guaranteed Delivery?</a></li>
<li><a href="#command-execution-reliability.message-ordering">7.11.4. Message Ordering</a></li>
<li><a href="#command-execution-reliability.failures-and-at-least-once-execution">7.11.5. Failures and <em>at-least-once</em> execution</a></li>
<li><a href="#command-execution-reliability.switching-between-at-least-once-and-at-most-once-operations">7.11.6. Switching between <em>at-least-once</em> and <em>at-most-once</em> operations</a></li>
<li><a href="#command-execution-reliability.clustered-operations">7.11.7. Clustered operations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#integration-extension">8. Integration and Extension</a>
<ul class="sectlevel2">
<li><a href="#codecs">8.1. Codecs</a>
<ul class="sectlevel3">
<li><a href="#codecs.why-bytebuffer-instead-of-byte">8.1.1. Why <code>ByteBuffer</code> instead of <code>byte[]</code></a></li>
<li><a href="#codecs.diversity-in-codecs">8.1.2. Diversity in Codecs</a></li>
<li><a href="#codecs.multi-threading">8.1.3. Multi-Threading</a></li>
<li><a href="#codecs.compression">8.1.4. Compression</a></li>
<li><a href="#codecs.examples">8.1.5. Examples</a></li>
</ul>
</li>
<li><a href="#cdi-support">8.2. CDI Support</a>
<ul class="sectlevel3">
<li><a href="#redisuri-producer">8.2.1. RedisURI producer</a></li>
<li><a href="#injection">8.2.2. Injection</a></li>
<li><a href="#activating-lettuces-cdi-extension">8.2.3. Activating Lettuce&#8217;s CDI extension</a></li>
</ul>
</li>
<li><a href="#spring-support">8.3. Spring Support</a>
<ul class="sectlevel3">
<li><a href="#spring.spring-data-redis">8.3.1. Spring Data Redis</a></li>
<li><a href="#spring.redis-client">8.3.2. Redis Client</a></li>
<li><a href="#spring.redis-cluster-client">8.3.3. Redis Cluster Client</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<a class="image" href="https://lettuce.io"><img src="images/lettuce-green-text@2x.png" alt="lettuce green text@2x" width="50%"></a>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>1. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document is the reference guide for Lettuce. It explains how to use Lettuce, its concepts, semantics, and the syntax.</p>
</div>
<div class="paragraph">
<p>You can read this reference guide in a linear fashion, or you can skip sections if something does not interest you.</p>
</div>
<div class="paragraph">
<p>This section provides some basic introduction to Redis. The rest of the document refers only to Lettuce features and assumes the user is familiar with Redis concepts.</p>
</div>
<div class="sect2">
<h3 id="overview.redis"><a class="anchor" href="#overview.redis"></a>1.1. Knowing Redis</h3>
<div class="paragraph">
<p>NoSQL stores have taken the storage world by storm. It is a vast domain with a plethora of solutions, terms and patterns (to make things worse even the term itself has multiple <a href="http://www.google.com/search?q=nosql+acronym">meanings</a>). While some of the principles are common, it is crucial that the user is familiar to some degree with Redis. The best way to get acquainted to this solutions is to read their documentation and follow their documentation - it usually doesn&#8217;t take more then 5-10 minutes to go through them and if you are coming from an RDMBS-only background many times these exercises can be an eye opener.</p>
</div>
<div class="paragraph">
<p>The jumping off ground for learning about Redis is <a href="http://www.redis.io/">redis.io</a>. Here is a list of other useful resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="http://try.redis.io/">interactive tutorial</a> introduces Redis.</p>
</li>
<li>
<p>The <a href="http://redis.io/commands">command references</a> explains Redis commands and contains links to getting started guides, reference documentation and tutorials.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_project_reactor"><a class="anchor" href="#_project_reactor"></a>1.2. Project Reactor</h3>
<div class="paragraph">
<p><a href="https://projectreactor.io">Reactor</a> is a highly optimized reactive library for building efficient, non-blocking
applications on the JVM based on the <a href="https://github.com/reactive-streams/reactive-streams-jvm">Reactive Streams Specification</a>.
Reactor based applications can sustain very high throughput message rates and operate with a very low memory footprint,
making it suitable for building efficient event-driven applications using the microservices architecture.</p>
</div>
<div class="paragraph">
<p>Reactor implements two publishers <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> and
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;T&gt;</a>, both of which support non-blocking back-pressure.
This enables exchange of data between threads with well-defined memory usage, avoiding unnecessary intermediate buffering or blocking.</p>
</div>
</div>
<div class="sect2">
<h3 id="_non_blocking_api_for_redis"><a class="anchor" href="#_non_blocking_api_for_redis"></a>1.3. Non-blocking API for Redis</h3>
<div class="paragraph">
<p>Lettuce is a scalable thread-safe Redis client based on <a href="http://netty.io">netty</a> and Reactor. Lettuce provides <a href="#basic-usage">synchronous</a>, <a href="#asynchronous-api">asynchronous</a> and <a href="#reactive-api">reactive</a> APIs to interact with Redis.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview.requirements"><a class="anchor" href="#overview.requirements"></a>1.4. Requirements</h3>
<div class="paragraph">
<p>Lettuce 4.x and 5.x binaries require JDK level 8.0 and above.</p>
</div>
<div class="paragraph">
<p>In terms of <a href="http://redis.io/">Redis</a>, at least 2.6.</p>
</div>
</div>
<div class="sect2">
<h3 id="_additional_help_resources"><a class="anchor" href="#_additional_help_resources"></a>1.5. Additional Help Resources</h3>
<div class="paragraph">
<p>Learning a new framework is not always straight forward. In this section, we try to provide what we think is an easy to follow guide for starting with Lettuce. However, if you encounter issues or you are just looking for an advice, feel free to use one of the links below:</p>
</div>
<div class="sect3">
<h4 id="overview.support"><a class="anchor" href="#overview.support"></a>1.5.1. Support</h4>
<div class="paragraph">
<p>There are a few support options available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lettuce on Stackoverflow <a href="http://stackoverflow.com/questions/tagged/lettuce">Stackoverflow</a> is a tag for all Lettuce users to share information and help each other. Note that registration is needed <strong>only</strong> for posting.</p>
</li>
<li>
<p>Get in touch with the community on <a href="https://gitter.im/lettuce-io/Lobby">Gitter</a>.</p>
</li>
<li>
<p>Google Group: <a href="https://groups.google.com/d/forum/lettuce-redis-client-users">lettuce-redis-client-users</a> or <a href="mailto:lettuce-redis-client-users@googlegroups.com">lettuce-redis-client-users@googlegroups.com</a>.</p>
</li>
<li>
<p>Report bugs (or ask questions) in Github issues <a href="https://github.com/lettuce-io/lettuce-core/issues" class="bare">https://github.com/lettuce-io/lettuce-core/issues</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="overview.development"><a class="anchor" href="#overview.development"></a>1.5.2. Following Development</h4>
<div class="paragraph">
<p>For information on the Lettuce source code repository, nightly builds and snapshot artifacts please see the <a href="https://lettuce.io">Lettuce homepage</a>. You can help make lettuce best serve the needs of the lettuce community by interacting with developers through the Community on <a href="http://stackoverflow.com/questions/tagged/lettuce">Stackoverflow</a>. To follow developer activity look for the mailing list information on the <a href="https://lettuce.io">lettuce homepage</a>. If you encounter a bug or want to suggest an improvement, please create a ticket on the lettuce issue <a href="https://github.com/lettuce-io/lettuce-core/issues">tracker</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_project_metadata"><a class="anchor" href="#_project_metadata"></a>1.5.3. Project Metadata</h4>
<div class="ulist">
<ul>
<li>
<p>Version Control – <a href="https://github.com/lettuce-io/lettuce-core" class="bare">https://github.com/lettuce-io/lettuce-core</a></p>
</li>
<li>
<p>Releases and Binary Packages – <a href="https://github.com/lettuce-io/lettuce-core/releases" class="bare">https://github.com/lettuce-io/lettuce-core/releases</a></p>
</li>
<li>
<p>Issue tracker – <a href="https://github.com/lettuce-io/lettuce-core/issues" class="bare">https://github.com/lettuce-io/lettuce-core/issues</a></p>
</li>
<li>
<p>Release repository – <a href="https://repo1.maven.org/maven2/" class="bare">https://repo1.maven.org/maven2/</a> (Maven Central)</p>
</li>
<li>
<p>Snapshot repository – <a href="https://oss.sonatype.org/content/repositories/snapshots/" class="bare">https://oss.sonatype.org/content/repositories/snapshots/</a> (OSS Sonatype Snapshots)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_where_to_go_from_here"><a class="anchor" href="#_where_to_go_from_here"></a>1.6. Where to go from here</h3>
<div class="ulist">
<ul>
<li>
<p>Head to <a href="#getting-started">Getting Started</a> if you feel like jumping straight into the code.</p>
</li>
<li>
<p>Go to <a href="#ha-sharding">High-Availability and Sharding</a> for Master/Replica, Redis Sentinel and Redis Cluster topics.</p>
</li>
<li>
<p>In order to dig deeper into the core features of Reactor:</p>
<div class="ulist">
<ul>
<li>
<p>If you’re looking for client configuration options, performance related behavior and how to use various transports, go to <a href="#advanced-usage">Advanced usage</a>.</p>
</li>
<li>
<p>See <a href="#integration-extension">Integration and Extension</a> for extending Lettuce with codecs or integrate it in your CDI/Spring application.</p>
</li>
<li>
<p>You want to know more about <strong>at-least-once</strong> and <strong>at-most-once</strong>? Take a look into <a href="#command-execution-reliability">Command execution reliability</a>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new-features"><a class="anchor" href="#new-features"></a>2. New &amp; Noteworthy</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="new-features.5-2-0"><a class="anchor" href="#new-features.5-2-0"></a>2.1. What&#8217;s new in Lettuce 5.2</h3>
<div class="ulist">
<ul>
<li>
<p>Allow randomization of read candidates using Redis Cluster</p>
</li>
<li>
<p>SSL support for Redis Sentinel</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-features.5-1-0"><a class="anchor" href="#new-features.5-1-0"></a>2.2. What&#8217;s new in Lettuce 5.1</h3>
<div class="ulist">
<ul>
<li>
<p>Add support for <code>ZPOPMIN</code>, <code>ZPOPMAX</code>, <code>BZPOPMIN</code>, <code>BZPOPMAX</code> commands.</p>
</li>
<li>
<p>Add support for Redis Command Tracing through Brave, see <a href="#client-resources">Configuring Client resources</a>.</p>
</li>
<li>
<p>Add support for <a href="https://redis.io/topics/streams-intro">Redis Streams</a>.</p>
</li>
<li>
<p>Asynchronous <code>connect()</code> for Master/Replica connections.</p>
</li>
<li>
<p><a href="#connection-pooling.asynchronous.usage">Asynchronous Connection Pooling</a> through <code>AsyncConnectionPoolSupport</code> and <code>AsyncPool</code>.</p>
</li>
<li>
<p>Dedicated exceptions for Redis <code>LOADING</code>, <code>BUSY</code>, and <code>NOSCRIPT</code> responses.</p>
</li>
<li>
<p>Commands in at-most-once mode (auto-reconnect disabled) are now canceled already on disconnect.</p>
</li>
<li>
<p>Global command timeouts (also for reactive and asynchronous API usage) configurable through <a href="#client-options">Client Options</a>.</p>
</li>
<li>
<p>Host and port mappers for Lettuce usage behind connection tunnels/proxies through <code>SocketAddressResolver</code>, see <a href="#client-resources">Configuring Client resources</a>.</p>
</li>
<li>
<p><code>SCRIPT LOAD</code> dispatch to all cluster nodes when issued through <code>RedisAdvancedClusterCommands</code>.</p>
</li>
<li>
<p>Reactive <code>ScanStream</code> to iterate over the keyspace using <code>SCAN</code> commands.</p>
</li>
<li>
<p>Transactions using Master/Replica connections are bound to the master node.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-features.5-0-0"><a class="anchor" href="#new-features.5-0-0"></a>2.3. What&#8217;s new in Lettuce 5.0</h3>
<div class="ulist">
<ul>
<li>
<p>New artifact coordinates: <code>io.lettuce:lettuce-core</code> and packages moved from <code>com.lambdaworks.redis</code> to <code>io.lettuce.core</code>.</p>
</li>
<li>
<p><a href="#reactive-api">Reactive API</a> now Reactive Streams-based using <a href="https://projectreactor.io/">Project Reactor</a>.</p>
</li>
<li>
<p><a href="#redis-command-interfaces">Redis Command Interfaces</a> supporting dynamic command invocation and Redis Modules.</p>
</li>
<li>
<p>Enhanced, immutable Key-Value objects.</p>
</li>
<li>
<p>Asynchronous Cluster connect.</p>
</li>
<li>
<p>Native transport support for Kqueue on macOS systems.</p>
</li>
<li>
<p>Removal of support for Guava.</p>
</li>
<li>
<p>Removal of deprecated <code>RedisConnection</code> and <code>RedisAsyncConnection</code> interfaces.</p>
</li>
<li>
<p>Java 9 compatibility.</p>
</li>
<li>
<p>HTML and PDF reference documentation along with a new project website: <a href="https://lettuce.io" class="bare">https://lettuce.io</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>3. Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can get started with Lettuce in various ways.</p>
</div>
<div class="sect2">
<h3 id="getting-started.get-it"><a class="anchor" href="#getting-started.get-it"></a>3.1. 1. Get it</h3>
<div class="sect3">
<h4 id="_for_maven_users"><a class="anchor" href="#_for_maven_users"></a>3.1.1. For Maven users:</h4>
<div class="paragraph">
<p>Add these lines to file pom.xml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>io.lettuce<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>lettuce-core<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>5.2.2.RELEASE<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_for_ivy_users"><a class="anchor" href="#_for_ivy_users"></a>3.1.2. For Ivy users:</h4>
<div class="paragraph">
<p>Add these lines to file ivy.xml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;ivy-module&gt;</span>
  <span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency</span> <span class="attribute-name">org</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">io.lettuce</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lettuce-core</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">rev</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">5.2.2.RELEASE</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/dependencies&gt;</span>
<span class="tag">&lt;/ivy-module&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_for_gradle_users"><a class="anchor" href="#_for_gradle_users"></a>3.1.3. For Gradle users:</h4>
<div class="paragraph">
<p>Add these lines to file build.gradle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
  compile <span class="string"><span class="delimiter">'</span><span class="content">io.lettuce:lettuce-core:5.2.2.RELEASE</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getting-started.plain-java"><a class="anchor" href="#getting-started.plain-java"></a>3.1.4. Plain Java</h4>
<div class="paragraph">
<p>Download the latest binary package from
<a href="https://github.com/lettuce-io/lettuce-core/releases" class="bare">https://github.com/lettuce-io/lettuce-core/releases</a> and extract the archive.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="getting-started.start-coding"><a class="anchor" href="#getting-started.start-coding"></a>3.2. 2. Start coding</h3>
<div class="paragraph">
<p>So easy! No more boring routines, we can start.</p>
</div>
<div class="paragraph">
<p>Import required classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">io.lettuce.core</span>.*;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now, write your code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient redisClient = RedisClient.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://password@localhost:6379/0</span><span class="delimiter">&quot;</span></span>);
StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = redisClient.connect();
RedisCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; syncCommands = connection.sync();

syncCommands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello, Redis!</span><span class="delimiter">&quot;</span></span>);

connection.close();
redisClient.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Done!</p>
</div>
<div class="paragraph">
<p>Do you want to see working examples?</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToRedis.java">Standalone Redis</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToRedisSSL.java">Standalone Redis with SSL</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToRedisUsingRedisSentinel.java">Redis Sentinel</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToRedisCluster.java">Redis Cluster</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToElastiCacheMaster.java">Connecting to a ElastiCache Master</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToMasterSlaveUsingElastiCacheCluster.java">Connecting to ElastiCache with Master/Replica</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/ConnectToRedisClusterSSL.java">Connecting to Azure Redis Cluster</a></p>
</li>
<li>
<p><a href="https://github.com/lettuce-io/lettuce-core/blob/5.2.2.RELEASE/src/test/java/io/lettuce/examples/SpringExample.java">Lettuce
with Spring</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connecting-redis"><a class="anchor" href="#connecting-redis"></a>4. Connecting Redis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Connections to a Redis Standalone, Sentinel, or Cluster require a
specification of the connection details. The unified form is <code>RedisURI</code>.
You can provide the database, password and timeouts within the
<code>RedisURI</code>. You have following possibilities to create a <code>RedisURI</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use an URI:</p>
<div class="literalblock">
<div class="content">
<pre>RedisURI.create("redis://localhost/");</pre>
</div>
</div>
</li>
<li>
<p>Use the Builder</p>
<div class="literalblock">
<div class="content">
<pre>RedisURI.Builder.redis("localhost", 6379).auth("password").database(1).build();</pre>
</div>
</div>
</li>
<li>
<p>Set directly the values in <code>RedisURI</code></p>
<div class="literalblock">
<div class="content">
<pre>new RedisURI("localhost", 6379, 60, TimeUnit.SECONDS);</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="redisuri.uri-syntax"><a class="anchor" href="#redisuri.uri-syntax"></a>4.1. URI syntax</h3>
<div class="paragraph">
<p><strong>Redis Standalone</strong></p>
</div>
<div class="paragraph">
<p><em>redis</em> <strong>://</strong> [<strong>:</strong> <em>password</em>@] <em>host</em> [<strong>:</strong> <em>port</em>] [<strong>/</strong> <em>database</em>][<strong>?</strong> [<em>timeout=timeout</em>[<em>d|h|m|s|ms|us|ns</em>]] [&amp;_database=database_]]</p>
</div>
<div class="paragraph">
<p><strong>Redis Standalone (SSL)</strong></p>
</div>
<div class="paragraph">
<p><em>rediss</em> <strong>://</strong> [<strong>:</strong> <em>password</em>@] <em>host</em> [<strong>:</strong> <em>port</em>] [<strong>/</strong> <em>database</em>][<strong>?</strong> [<em>timeout=timeout</em>[<em>d|h|m|s|ms|us|ns</em>]] [&amp;_database=database_]]</p>
</div>
<div class="paragraph">
<p><strong>Redis Standalone (Unix Domain Sockets)</strong></p>
</div>
<div class="paragraph">
<p><em>redis-socket</em> <strong>://</strong> <em class="<strong>:</strong> _password_@">path</em> [<strong>?</strong>[<em>timeout=timeout</em>[<em>d|h|m|s|ms|us|ns</em>]][&amp;_database=database_]]</p>
</div>
<div class="paragraph">
<p><strong>Redis Sentinel</strong></p>
</div>
<div class="paragraph">
<p><em>redis-sentinel</em> <strong>://</strong> [<strong>:</strong> <em>password</em>@] <em>host1</em>[<strong>:</strong> <em>port1</em>] [, <em>host2</em>[<strong>:</strong> <em>port2</em>]] [, <em>hostN</em>[<strong>:</strong> <em>portN</em>]] [<strong>/</strong> <em>database</em>][<strong>?</strong>[<em>timeout=timeout</em>[<em>d|h|m|s|ms|us|ns</em>]] [&amp;_sentinelMasterId=sentinelMasterId_] [&amp;_database=database_]]</p>
</div>
<div class="paragraph">
<p><strong>Schemes</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>redis</code> Redis Standalone</p>
</li>
<li>
<p><code>rediss</code> Redis Standalone SSL</p>
</li>
<li>
<p><code>redis-socket</code> Redis Standalone Unix Domain Socket</p>
</li>
<li>
<p><code>redis-sentinel</code> Redis Sentinel</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Timeout units</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>d</code> Days</p>
</li>
<li>
<p><code>h</code> Hours</p>
</li>
<li>
<p><code>m</code> Minutes</p>
</li>
<li>
<p><code>s</code> Seconds</p>
</li>
<li>
<p><code>ms</code> Milliseconds</p>
</li>
<li>
<p><code>us</code> Microseconds</p>
</li>
<li>
<p><code>ns</code> Nanoseconds</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hint: The database parameter within the query part has higher precedence than the database in the path.</p>
</div>
<div class="paragraph">
<p>RedisURI supports Redis Standalone, Redis Sentinel and Redis Cluster
with plain, SSL, TLS and unix domain socket connections.</p>
</div>
</div>
<div class="sect2">
<h3 id="basic-usage"><a class="anchor" href="#basic-usage"></a>4.2. Basic Usage</h3>
<div class="exampleblock">
<div class="title">Example 1. Basic usage</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://localhost</span><span class="delimiter">&quot;</span></span>);          <i class="conum" data-value="1"></i><b>(1)</b>

StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connect(); <i class="conum" data-value="2"></i><b>(2)</b>

RedisCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = connection.sync();            <i class="conum" data-value="3"></i><b>(3)</b>

<span class="predefined-type">String</span> value = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>);                                    <i class="conum" data-value="4"></i><b>(4)</b>

...

connection.close();                                                    <i class="conum" data-value="5"></i><b>(5)</b>

client.shutdown();                                                     <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the <code>RedisClient</code> instance and provide a Redis URI pointing to
localhost, Port 6379 (default port).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Open a Redis Standalone connection. The endpoint is used from the initialized <code>RedisClient</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Obtain the command API for synchronous execution. Lettuce supports asynchronous and reactive execution models, too.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Issue a <code>GET</code> command to get the key <code>foo</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Close the connection when you&#8217;re done. This happens usually at the very end of your application.
Connections are designed to be long-lived.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Shut down the client instance to free threads and resources. This happens usually at the very end of your application.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Each Redis command is implemented by one or more methods with names
identical to the lowercase Redis command name. Complex commands with
multiple modifiers that change the result type include the CamelCased
modifier as part of the command name, e.g. <code>zrangebyscore</code> and
<code>zrangebyscoreWithScores</code>.</p>
</div>
<div class="paragraph">
<p>Redis connections are designed to be long-lived and thread-safe, and if
the connection is lost will reconnect until <code>close()</code> is called. Pending
commands that have not timed out will be (re)sent after successful
reconnection.</p>
</div>
<div class="paragraph">
<p>All connections inherit a default timeout from their RedisClient and<br>
and will throw a <code>RedisException</code> when non-blocking commands fail to
return a result before the timeout expires. The timeout defaults to 60
seconds and may be changed in the RedisClient or for each connection.
Synchronous methods will throw a <code>RedisCommandExecutionException</code> in
case Redis responds with an error. Asynchronous connections do not throw
exceptions when Redis responds with an error.</p>
</div>
<div class="sect3">
<h4 id="basic.redisuri"><a class="anchor" href="#basic.redisuri"></a>4.2.1. RedisURI</h4>
<div class="paragraph">
<p>The RedisURI contains the host/port and can carry
authentication/database details. On a successful connect you get
authenticated, and the database is selected afterward. This applies<br>
also after re-establishing a connection after a connection loss.</p>
</div>
<div class="paragraph">
<p>A Redis URI can also be created from an URI string. Supported formats
are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>redis://[password@]host[:port][/databaseNumber]</code> Plaintext Redis
connection</p>
</li>
<li>
<p><code>rediss://[password@]host[:port][/databaseNumber]</code>
<a href="#ssl">SSL Connections</a> Redis connection</p>
</li>
<li>
<p><code>redis-sentinel://[password@]host[:port][,host2[:port2]][/databaseNumber]#sentinelMasterId</code>
for using Redis Sentinel</p>
</li>
<li>
<p><code>redis-socket:///path/to/socket</code> <a href="#unix-domain-sockets">Unix Domain Sockets</a> connection to Redis</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="basic.exceptions"><a class="anchor" href="#basic.exceptions"></a>4.2.2. Exceptions</h4>
<div class="paragraph">
<p>In the case of an exception/error response from Redis, you’ll receive a
<code>RedisException</code> containing<br>
the error message. <code>RedisException</code> is a <code>RuntimeException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="basic.examples"><a class="anchor" href="#basic.examples"></a>4.2.3. Examples</h4>
<div class="exampleblock">
<div class="title">Example 2. Using host and port and set the default timeout to 20 seconds</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create(RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>));
client.setDefaultTimeout(<span class="integer">20</span>, <span class="predefined-type">TimeUnit</span>.SECONDS);

<span class="comment">// …</span>

client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 3. Using RedisURI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>)
                                .withPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">authentication</span><span class="delimiter">&quot;</span></span>)
                                .withDatabase(<span class="integer">2</span>)
                                .build();
RedisClient client = RedisClient.create(redisUri);

<span class="comment">// …</span>

client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 4. SSL RedisURI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>)
                                .withSsl(<span class="predefined-constant">true</span>)
                                .withPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">authentication</span><span class="delimiter">&quot;</span></span>)
                                .withDatabase(<span class="integer">2</span>)
                                .build();
RedisClient client = RedisClient.create(redisUri);

<span class="comment">// …</span>

client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 5. String RedisURI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://authentication@localhost/2</span><span class="delimiter">&quot;</span></span>);
RedisClient client = RedisClient.create(redisUri);

<span class="comment">// …</span>

client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="asynchronous-api"><a class="anchor" href="#asynchronous-api"></a>4.3. Asynchronous API</h3>
<div class="paragraph">
<p>This guide will give you an impression how and when to use the
asynchronous API provided by lettuce 4.x.</p>
</div>
<div class="sect3">
<h4 id="asynchronous-api.motivation"><a class="anchor" href="#asynchronous-api.motivation"></a>4.3.1. Motivation</h4>
<div class="paragraph">
<p>Asynchronous methodologies allow you to utilize better system resources,
instead of wasting threads waiting for network or disk I/O. Threads can
be fully utilized to perform other work instead. lettuce facilitates
asynchronicity from building the client on top of <a href="http://netty.io">netty</a>
that is a multithreaded, event-driven I/O framework. All communication
is handled asynchronously. Once the foundation is able to processes
commands concurrently, it is convenient to take advantage from the
asynchronicity. It is way harder to turn a blocking and synchronous
working software into a concurrently processing system.</p>
</div>
<div class="sect4">
<h5 id="asynchronous-api.understanding-asynchronicity"><a class="anchor" href="#asynchronous-api.understanding-asynchronicity"></a>Understanding Asynchronicity</h5>
<div class="paragraph">
<p>Asynchronicity permits other processing to continue before the
transmission has finished and the response of the transmission is
processed. This means, in the context of lettuce and especially Redis,
that multiple commands can be issued serially without the need of
waiting to finish the preceding command. This mode of operation is also
known as <a href="http://redis.io/topics/pipelining">Pipelining</a>. The following
example should give you an impression of the mode of operation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Given client <em>A</em> and client <em>B</em></p>
</li>
<li>
<p>Client <em>A</em> triggers command <code>SET A=B</code></p>
</li>
<li>
<p>Client <em>B</em> triggers at the same time of Client <em>A</em> command <code>SET C=D</code></p>
</li>
<li>
<p>Redis receives command from Client <em>A</em></p>
</li>
<li>
<p>Redis receives command from Client <em>B</em></p>
</li>
<li>
<p>Redis processes <code>SET A=B</code> and responds <code>OK</code> to Client <em>A</em></p>
</li>
<li>
<p>Client <em>A</em> receives the response and stores the response in the
response handle</p>
</li>
<li>
<p>Redis processes <code>SET C=D</code> and responds <code>OK</code> to Client <em>B</em></p>
</li>
<li>
<p>Client <em>B</em> receives the response and stores the response in the
response handle</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both clients from the example above can be either two threads or
connections within an application or two physically separated clients.</p>
</div>
<div class="paragraph">
<p>Clients can operate concurrently to each other by either being separate
processes, threads, event-loops, actors, fibers, etc. Redis processes
incoming commands serially and operates mostly single-threaded. This
means, commands are processed in the order they are received with some
characteristic that we&#8217;ll cover later.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the simplified example and enhance it by some program flow
details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Given client <em>A</em></p>
</li>
<li>
<p>Client <em>A</em> triggers command <code>SET A=B</code></p>
</li>
<li>
<p>Client <em>A</em> uses the asynchronous API and can perform other processing</p>
</li>
<li>
<p>Redis receives command from Client <em>A</em></p>
</li>
<li>
<p>Redis processes <code>SET A=B</code> and responds <code>OK</code> to Client <em>A</em></p>
</li>
<li>
<p>Client <em>A</em> receives the response and stores the response in the
response handle</p>
</li>
<li>
<p>Client <em>A</em> can access now the response to its command without waiting
(non-blocking)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Client <em>A</em> takes advantage from not waiting on the result of the
command so it can process computational work or issue another Redis
command. The client can work with the command result as soon as the
response is available.</p>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-api.impact-of-asynchronicity-to-the-synchronous-api"><a class="anchor" href="#asynchronous-api.impact-of-asynchronicity-to-the-synchronous-api"></a>Impact of asynchronicity to the synchronous API</h5>
<div class="paragraph">
<p>While this guide helps you to understand the asynchronous API it is
worthwhile to learn the impact on the synchronous API. The general
approach of the synchronous API is no different than the asynchronous
API. In both cases, the same facilities are used to invoke and transport
commands to the Redis server. The only difference is a blocking behavior
of the caller that is using the synchronous API. Blocking happens on
command level and affects only the command completion part, meaning
multiple clients using the synchronous API can invoke commands on the
same connection and at the same time without blocking each other. A call
on the synchronous API is unblocked at the moment a command response was
processed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Given client <em>A</em> and client <em>B</em></p>
</li>
<li>
<p>Client <em>A</em> triggers command <code>SET A=B</code> on the synchronous API and waits
for the result</p>
</li>
<li>
<p>Client <em>B</em> triggers at the same time of Client <em>A</em> command <code>SET C=D</code>
on the synchronous API and waits for the result</p>
</li>
<li>
<p>Redis receives command from Client <em>A</em></p>
</li>
<li>
<p>Redis receives command from Client <em>B</em></p>
</li>
<li>
<p>Redis processes <code>SET A=B</code> and responds <code>OK</code> to Client <em>A</em></p>
</li>
<li>
<p>Client <em>A</em> receives the response and unblocks the program flow of
Client <em>A</em></p>
</li>
<li>
<p>Redis processes <code>SET C=D</code> and responds <code>OK</code> to Client <em>B</em></p>
</li>
<li>
<p>Client <em>B</em> receives the response and unblocks the program flow of
Client <em>B</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, there are some cases you should not share a connection among
threads to avoid side-effects. The cases are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Disabling flush-after-command to improve performance</p>
</li>
<li>
<p>The use of blocking operations like <code>BLPOP</code>. Blocking operations are
queued on Redis until they can be executed. While one connection is
blocked, other connections can issue commands to Redis. Once a command
unblocks the blocking command (that said an <code>LPUSH</code> or <code>RPUSH</code> hits the
list), the blocked connection is unblocked and can proceed after that.</p>
</li>
<li>
<p>Transactions</p>
</li>
<li>
<p>Using multiple databases</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-api.result-handles"><a class="anchor" href="#asynchronous-api.result-handles"></a>Result handles</h5>
<div class="paragraph">
<p>Every command invocation on the asynchronous API creates a
<code>RedisFuture&lt;T&gt;</code> that can be canceled, awaited and subscribed
(listener). A <code>CompleteableFuture&lt;T&gt;</code> or <code>RedisFuture&lt;T&gt;</code> is a pointer
to the result that is initially unknown since the computation of its
value is yet incomplete. A <code>RedisFuture&lt;T&gt;</code> provides operations for
synchronization and chaining.</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. First steps with <code>CompletableFuture</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">CompletableFuture&lt;<span class="predefined-type">String</span>&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current state: </span><span class="delimiter">&quot;</span></span> + future.isDone());

future.complete(<span class="string"><span class="delimiter">&quot;</span><span class="content">my value</span><span class="delimiter">&quot;</span></span>);

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current state: </span><span class="delimiter">&quot;</span></span> + future.isDone());
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + future.get());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Current state: false
Current state: true
Got value: my value</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attaching a listener to a future allows chaining. Promises can be used
synonymous to futures, but not every future is a promise. A promise
guarantees a callback/notification and thus it has come to its name.</p>
</div>
<div class="paragraph">
<p>A simple listener that gets called once the future completes:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Using listeners with <code>CompletableFuture</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">final</span> CompletableFuture&lt;<span class="predefined-type">String</span>&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();

future.thenRun(<span class="keyword">new</span> <span class="predefined-type">Runnable</span>() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> run() {
        <span class="keyword">try</span> {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + future.get());
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            e.printStackTrace();
        }

    }
});

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current state: </span><span class="delimiter">&quot;</span></span> + future.isDone());
future.complete(<span class="string"><span class="delimiter">&quot;</span><span class="content">my value</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current state: </span><span class="delimiter">&quot;</span></span> + future.isDone());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The value processing moves from the caller into a listener that is then
called by whoever completes the future. The example prints the following
lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Current state: false
Got value: my value
Current state: true</pre>
</div>
</div>
<div class="paragraph">
<p>The code from above requires exception handling since calls to the
<code>get()</code> method can lead to exceptions. Exceptions raised during the
computation of the <code>Future&lt;T&gt;</code> are transported within an
<code>ExecutionException</code>. Another exception that may be thrown is the
<code>InterruptedException</code>. This is because calls to <code>get()</code> are blocking
calls and the blocked thread can be interrupted at any time. Just think
about a system shutdown.</p>
</div>
<div class="paragraph">
<p>The <code>CompletionStage&lt;T&gt;</code> type allows since Java 8 a much more
sophisticated handling of futures. A <code>CompletionStage&lt;T&gt;</code> can consume,
transform and build a chain of value processing. The code from above can
be rewritten in Java 8 in the following style:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Using a <code>Consumer</code> future listener</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">CompletableFuture&lt;<span class="predefined-type">String</span>&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();

future.thenAccept(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> value) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value);
    }
});

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current state: </span><span class="delimiter">&quot;</span></span> + future.isDone());
future.complete(<span class="string"><span class="delimiter">&quot;</span><span class="content">my value</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current state: </span><span class="delimiter">&quot;</span></span> + future.isDone());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Current state: false
Got value: my value
Current state: true</pre>
</div>
</div>
<div class="paragraph">
<p>You can find the full reference for the <code>CompletionStage&lt;T&gt;</code> type in the
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html">Java
8 API documentation</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-api.creating-futures-using-lettuce"><a class="anchor" href="#asynchronous-api.creating-futures-using-lettuce"></a>4.3.2. Creating futures using lettuce</h4>
<div class="paragraph">
<p>lettuce futures can be used for initial and chaining operations. When
using lettuce futures, you will notice the non-blocking behavior. This
is because all I/O and command processing are handled asynchronously
using the netty EventLoop. The lettuce <code>RedisFuture&lt;T&gt;</code> extends a
<code>CompletionStage&lt;T&gt;</code> so all methods of the base type are available.</p>
</div>
<div class="paragraph">
<p>lettuce exposes its futures on the Standalone, Sentinel,
Publish/Subscribe and Cluster APIs.</p>
</div>
<div class="paragraph">
<p>Connecting to Redis is insanely simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://localhost</span><span class="delimiter">&quot;</span></span>);
RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = client.connect().async();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next step, obtaining a value from a key requires the <code>GET</code>
operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-api.consuming-futures"><a class="anchor" href="#asynchronous-api.consuming-futures"></a>4.3.3. Consuming futures</h4>
<div class="paragraph">
<p>The first thing you want to do when working with futures is to consume
them. Consuming a futures means obtaining the value. Here is an example
that blocks the calling thread and prints the value:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. <code>GET</code> a key</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> value = future.get();
<span class="predefined-type">System</span>.out.println(value);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Invocations to the <code>get()</code> method (pull-style) block the calling thread
at least until the value is computed but in the worst case indefinitely.
Using timeouts is always a good idea to not exhaust your threads.</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Blocking synchronization</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> {
    RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);
    <span class="predefined-type">String</span> value = future.get(<span class="integer">1</span>, <span class="predefined-type">TimeUnit</span>.MINUTES);
    <span class="predefined-type">System</span>.out.println(value);
} <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
    e.printStackTrace();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The example will wait at most 1 minute for the future to complete. If
the timeout exceeds, a <code>TimeoutException</code> is thrown to signal the
timeout.</p>
</div>
<div class="paragraph">
<p>Futures can also be consumed in a push style, meaning when the
<code>RedisFuture&lt;T&gt;</code> is completed, a follow-up action is triggered:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Using a <code>Consumer</code> listener with <code>GET</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

future.thenAccept(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> value) {
        <span class="predefined-type">System</span>.out.println(value);
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, written in Java 8 lambdas:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Using a <code>Consumer</code> lambda with <code>GET</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

future.thenAccept(<span class="predefined-type">System</span>.out::println);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>lettuce futures are completed on the netty EventLoop. Consuming and
chaining futures on the default thread is always a good idea except for
one case: Blocking/long-running operations. As a rule of thumb, never
block the event loop. If you need to chain futures using blocking calls,
use the <code>thenAcceptAsync()</code>/<code>thenRunAsync()</code> methods to fork the
processing to another thread. The <code>&#8230;&#8203;async()</code> methods need a threading
infrastructure for execution, by default the <code>ForkJoinPool.commonPool()</code>
is used. The <code>ForkJoinPool</code> is statically constructed and does not grow
with increasing load. Using default <code>Executor</code>s is almost always the
better idea.</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Asynchronous listener notification</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Executor</span> sharedExecutor = ...
RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

future.thenAcceptAsync(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> value) {
        <span class="predefined-type">System</span>.out.println(value);
    }
}, sharedExecutor);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-api.synchronizing-futures"><a class="anchor" href="#asynchronous-api.synchronizing-futures"></a>4.3.4. Synchronizing futures</h4>
<div class="paragraph">
<p>A key point when using futures is the synchronization. Futures are
usually used to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Trigger multiple invocations without the urge to wait for the
predecessors (Batching)</p>
</li>
<li>
<p>Invoking a command without awaiting the result at all (Fire&amp;Forget)</p>
</li>
<li>
<p>Invoking a command and perform other computing in the meantime
(Decoupling)</p>
</li>
<li>
<p>Adding concurrency to certain computational efforts (Concurrency)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are several ways how to wait or get notified in case a future
completes. Certain synchronization techniques apply to some motivations
why you want to use futures.</p>
</div>
<div class="sect4">
<h5 id="asynchronous-api.blocking-synchronization"><a class="anchor" href="#asynchronous-api.blocking-synchronization"></a>Blocking synchronization</h5>
<div class="paragraph">
<p>Blocking synchronization comes handy if you perform batching/add
concurrency to certain parts of your system. An example to batching can
be setting/retrieving multiple values and awaiting the results before a
certain point within processing.</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Getting multiple keys asynchronously</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;RedisFuture&lt;<span class="predefined-type">String</span>&gt;&gt; futures = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;RedisFuture&lt;<span class="predefined-type">String</span>&gt;&gt;();

<span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; <span class="integer">10</span>; i++) {
    futures.add(commands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key-</span><span class="delimiter">&quot;</span></span> + i, <span class="string"><span class="delimiter">&quot;</span><span class="content">value-</span><span class="delimiter">&quot;</span></span> + i));
}

LettuceFutures.awaitAll(<span class="integer">1</span>, <span class="predefined-type">TimeUnit</span>.MINUTES, futures.toArray(<span class="keyword">new</span> RedisFuture[futures.size()]));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The code from above does not wait until a certain command completes
before it issues another one. The synchronization is done after all
commands are issued. The example code can easily be turned into a
Fire&amp;Forget pattern by omitting the call to <code>LettuceFutures.awaitAll()</code>.</p>
</div>
<div class="paragraph">
<p>A single future execution can be also awaited, meaning an opt-in to wait
for a certain time but without raising an exception:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. Using <code>RedisFuture.await</code> to wait for a result</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

<span class="keyword">if</span>(!future.await(<span class="integer">1</span>, <span class="predefined-type">TimeUnit</span>.MINUTES)) {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Could not complete within the timeout</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Calling <code>await()</code> is friendlier to call since it throws only an
<code>InterruptedException</code> in case the blocked thread is interrupted. You
are already familiar with the <code>get()</code> method for synchronization, so we
will not bother you with this one.</p>
</div>
<div class="paragraph">
<p>At last, there is another way to synchronize futures in a blocking way.
The major caveat is that you will become responsible to handle thread
interruptions. If you do not handle that aspect, you will not be able to
shut down your system properly if it is in a running state.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">while</span> (!future.isDone()) {
    <span class="comment">// do something ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the <code>isDone()</code> method does not aim primarily for synchronization
use, it might come handy to perform other computational efforts while
the command is executed.</p>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-api.chaining-synchronization"><a class="anchor" href="#asynchronous-api.chaining-synchronization"></a>Chaining synchronization</h5>
<div class="paragraph">
<p>Futures can be synchronized/chained in a non-blocking style to improve
thread utilization. Chaining works very well in systems relying on
event-driven characteristics. Future chaining builds up a chain of one
or more futures that are executed serially, and every chain member
handles a part in the computation. The <code>CompletionStage&lt;T&gt;</code> API offers
various methods to chain and transform futures. A simple transformation
of the value can be done using the <code>thenApply()</code> method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Future chaining</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">future.thenApply(<span class="keyword">new</span> Function&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Integer</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Integer</span> apply(<span class="predefined-type">String</span> value) {
        <span class="keyword">return</span> value.length();
    }
}).thenAccept(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">Integer</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">Integer</span> integer) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + integer);
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, written in Java 8 lambdas:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Future chaining with lambdas</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">future.thenApply(<span class="predefined-type">String</span>::length)
    .thenAccept(integer -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + integer));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>thenApply()</code> method accepts a function that transforms the value
into another one. The final <code>thenAccept()</code> method consumes the value for
final processing.</p>
</div>
<div class="paragraph">
<p>You have already seen the <code>thenRun()</code> method from previous examples. The
<code>thenRun()</code> method can be used to handle future completions in case the
data is not crucial to your flow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">future.thenRun(<span class="keyword">new</span> <span class="predefined-type">Runnable</span>() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> run() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Finished the future.</span><span class="delimiter">&quot;</span></span>);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind to execute the <code>Runnable</code> on a custom <code>Executor</code> if you are
doing blocking calls within the <code>Runnable</code>.</p>
</div>
<div class="paragraph">
<p>Another chaining method worth mentioning is the either-or chaining.
A couple of <code>&#8230;&#8203;Either()</code> methods are available on a
<code>CompletionStage&lt;T&gt;</code>, see the
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html">Java
8 API docs</a> for the full reference. The either-or pattern consumes the
value from the first future that is completed. A good example might be
two services returning the same data, for instance, a Master-Replica
scenario, but you want to return the data as fast as possible:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Read from Master and Replica and continue with the first response</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisStringAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; master = masterClient.connect().async();
RedisStringAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; replica = replicaClient.connect().async();

RedisFuture&lt;<span class="predefined-type">String</span>&gt; future = master.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);
future.acceptEither(replica.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>), <span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> value) {
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value);
    }
});</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-api.error-handling"><a class="anchor" href="#asynchronous-api.error-handling"></a>4.3.5. Error handling</h4>
<div class="paragraph">
<p>Error handling is an indispensable component of every real world
application and should to be considered from the beginning on. Futures
provide some mechanisms to deal with errors.</p>
</div>
<div class="paragraph">
<p>In general, you want to react in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Return a default value instead</p>
</li>
<li>
<p>Use a backup future</p>
</li>
<li>
<p>Retry the future</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>RedisFuture&lt;T&gt;</code>s transport exceptions if any occurred. Calls to the
<code>get()</code> method throw the occurred exception wrapped within an
<code>ExecutionException</code> (this is different to lettuce 3.x). You can find
more details within the Javadoc on
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html">CompletionStage</a>.</p>
</div>
<div class="paragraph">
<p>The following code falls back to a default value after it runs to an
exception by using the <code>handle()</code> method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. Future listener receiving result and error objects</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">future.handle(<span class="keyword">new</span> BiFunction&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Throwable</span>, <span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Integer</span> apply(<span class="predefined-type">String</span> value, <span class="predefined-type">Throwable</span> throwable) {
        <span class="keyword">if</span>(throwable != <span class="predefined-constant">null</span>) {
          <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">default value</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">return</span> value;
    }
}).thenAccept(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> value) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value);
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>More sophisticated code could decide on behalf of the throwable type
that value to return, as the shortcut example using the
<code>exceptionally()</code> method:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. Future recovery with Exception handlers</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">future.exceptionally(<span class="keyword">new</span> Function&lt;<span class="predefined-type">Throwable</span>, <span class="predefined-type">String</span>&gt;() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> apply(<span class="predefined-type">Throwable</span> throwable) {
        <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> <span class="exception">IllegalStateException</span>) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">default value</span><span class="delimiter">&quot;</span></span>;
        }

        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">other default value</span><span class="delimiter">&quot;</span></span>;
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Retrying futures and recovery using futures is not part of the Java 8
<code>CompleteableFuture&lt;T&gt;</code>. See the <a href="#reactive-api">Reactive API</a>
for comfortable ways handling with exceptions.</p>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-api.examples"><a class="anchor" href="#asynchronous-api.examples"></a>4.3.6. Examples</h4>
<div class="exampleblock">
<div class="title">Example 21. Basic operations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = client.connect().async();
RedisFuture&lt;<span class="predefined-type">String</span>&gt; set = async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
RedisFuture&lt;<span class="predefined-type">String</span>&gt; get = async.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

set.get() == <span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>
get.get() == <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 22. Waiting for a future with a timeout</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = client.connect().async();
RedisFuture&lt;<span class="predefined-type">String</span>&gt; set = async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
RedisFuture&lt;<span class="predefined-type">String</span>&gt; get = async.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

set.await(<span class="integer">1</span>, SECONDS) == <span class="predefined-constant">true</span>
set.get() == <span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>
get.get(<span class="integer">1</span>, <span class="predefined-type">TimeUnit</span>.MINUTES) == <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 23. Using a listener with <code>RedisFuture</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisStringAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = client.connect().async();
RedisFuture&lt;<span class="predefined-type">String</span>&gt; set = async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);

<span class="predefined-type">Runnable</span> listener = <span class="keyword">new</span> <span class="predefined-type">Runnable</span>() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> run() {
            ...;
    }
};

set.thenRun(listener);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactive-api"><a class="anchor" href="#reactive-api"></a>4.4. Reactive API</h3>
<div class="paragraph">
<p>This guide helps you to understand the Reactive Stream pattern and aims to give you a general understanding of how to build reactive applications.</p>
</div>
<div class="sect3">
<h4 id="reactive.5.motivation"><a class="anchor" href="#reactive.5.motivation"></a>4.4.1. Motivation</h4>
<div class="paragraph">
<p>Asynchronous and reactive methodologies allow you to utilize better system resources, instead of wasting threads waiting for network or disk I/O. Threads can be fully utilized to perform other work instead.</p>
</div>
<div class="paragraph">
<p>A broad range of technologies exists to facilitate this style of programming, ranging from the very limited and less usable <code>java.util.concurrent.Future</code> to complete libraries and runtimes like Akka. <a href="http://projectreactor.io/">Project Reactor</a>, has a very rich set of operators to compose asynchronous workflows, it has no further dependencies to other frameworks and supports the very mature Reactive Streams model.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.understanding-reactive-streams"><a class="anchor" href="#reactive.5.understanding-reactive-streams"></a>4.4.2. Understanding Reactive Streams</h4>
<div class="paragraph">
<p>Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.</p>
</div>
<div class="paragraph">
<p>The scope of Reactive Streams is to find a minimal set of interfaces, methods, and protocols that will describe the necessary operations and entities to achieve the goal—asynchronous streams of data with non-blocking back pressure.</p>
</div>
<div class="paragraph">
<p>It is an interoperability standard between multiple reactive composition libraries that allow interaction without the need of bridging between libraries in application code.</p>
</div>
<div class="paragraph">
<p>The integration of Reactive Streams is usually accompanied with the use of a composition library that hides the complexity of bare <code>Publisher&lt;T&gt;</code> and <code>Subscriber&lt;T&gt;</code> types behind an easy-to-use API. Lettuce uses <a href="http://projectreactor.io/">Project Reactor</a> that exposes its publishers as <code>Mono</code> and <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p>For more information about Reactive Streams see <a href="http://reactive-streams.org" class="bare">http://reactive-streams.org</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.understanding-publishers"><a class="anchor" href="#reactive.5.understanding-publishers"></a>4.4.3. Understanding Publishers</h4>
<div class="paragraph">
<p>Asynchronous processing decouples I/O or computation from the thread that invoked the operation. A handle to the result is given back, usually a <code>java.util.concurrent.Future</code> or similar, that returns either a single object, a collection or an exception. Retrieving a result, that was fetched asynchronously is usually not the end of processing one flow. Once data is obtained, further requests can be issued, either always or conditionally. With Java 8 or the Promise pattern, linear chaining of futures can be set up so that subsequent asynchronous requests are issued. Once conditional processing is needed, the asynchronous flow has to be interrupted and synchronized. While this approach is possible, it does not fully utilize the advantage of asynchronous processing.</p>
</div>
<div class="paragraph">
<p>In contrast to the preceding examples, <code>Publisher&lt;T&gt;</code> objects answer the multiplicity and asynchronous questions in a different fashion: By inverting the <code>Pull</code> pattern into a <code>Push</code> pattern.</p>
</div>
<div class="paragraph">
<p><strong>A Publisher is the asynchronous/push “dual” to the synchronous/pull Iterable</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">event</th>
<th class="tableblock halign-left valign-top">Iterable (pull)</th>
<th class="tableblock halign-left valign-top">Publisher (push)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">retrieve data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T next()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onNext(T)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">discover error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">throws Exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onError(Exception)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">complete</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!hasNext()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onCompleted()</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An <code>Publisher&lt;T&gt;</code> supports emission sequences of values or even infinite streams, not just the emission of single scalar values (as Futures do). You will very much appreciate this fact once you start to work on streams instead of single values. Project Reactor uses two types in its vocabulary: <code>Mono</code> and <code>Flux</code> that are both publishers.</p>
</div>
<div class="paragraph">
<p>A <code>Mono</code> can emit <code>0</code> to <code>1</code> events while a <code>Flux</code> can emit <code>0</code> to <code>N</code> events.</p>
</div>
<div class="paragraph">
<p>A <code>Publisher&lt;T&gt;</code> is not biased toward some particular source of concurrency or asynchronicity and how the underlying code is executed - synchronous or asynchronous, running within a <code>ThreadPool</code>. As a consumer of a <code>Publisher&lt;T&gt;</code>, you leave the actual implementation to the supplier, who can change it later on without you having to adapt your code.</p>
</div>
<div class="paragraph">
<p>The last key point of a <code>Publisher&lt;T&gt;</code> is that the underlying processing is not started at the time the <code>Publisher&lt;T&gt;</code> is obtained, rather its started at the moment an observer subscribes or signals demand to the <code>Publisher&lt;T&gt;</code>. This is a crucial difference to a <code>java.util.concurrent.Future</code>, which is started somewhere at the time it is created/obtained. So if no observer ever subscribes to the <code>Publisher&lt;T&gt;</code>, nothing ever will happen.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.a-word-on-the-lettuce-reactive-api"><a class="anchor" href="#reactive.5.a-word-on-the-lettuce-reactive-api"></a>4.4.4. A word on the lettuce Reactive API</h4>
<div class="paragraph">
<p>All commands return a <code>Flux&lt;T&gt;</code>, <code>Mono&lt;T&gt;</code> or <code>Mono&lt;Void&gt;</code> to which a <code>Subscriber</code> can subscribe to. That subscriber reacts to whatever item or sequence of items the <code>Publisher&lt;T&gt;</code> emits. This pattern facilitates concurrent operations because it does not need to block while waiting for the <code>Publisher&lt;T&gt;</code> to emit objects. Instead, it creates a sentry in the form of a <code>Subscriber</code> that stands ready to react appropriately at whatever future time the <code>Publisher&lt;T&gt;</code> does so.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.consuming-publisher"><a class="anchor" href="#reactive.5.consuming-publisher"></a>4.4.5. Consuming <code>Publisher&lt;T&gt;</code></h4>
<div class="paragraph">
<p>The first thing you want to do when working with publishers is to consume them. Consuming a publisher means subscribing to it. Here is an example that subscribes and prints out all the items emitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).subscribe(<span class="keyword">new</span> Subscriber&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="directive">public</span> <span class="type">void</span> onSubscribe(Subscription s) {
        s.request(<span class="integer">3</span>);
    }

    <span class="directive">public</span> <span class="type">void</span> onNext(<span class="predefined-type">String</span> s) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + s + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">public</span> <span class="type">void</span> onError(<span class="predefined-type">Throwable</span> t) {

    }

    <span class="directive">public</span> <span class="type">void</span> onComplete() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Completed</span><span class="delimiter">&quot;</span></span>);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello Ben
Hello Michael
Hello Mark
Completed</pre>
</div>
</div>
<div class="paragraph">
<p>You can see that the Subscriber (or Observer) gets notified of every event and also receives the completed event. A <code>Publisher&lt;T&gt;</code> emits items until either an exception is raised or the <code>Publisher&lt;T&gt;</code> finishes the emission calling <code>onCompleted</code>. No further elements are emitted after that time.</p>
</div>
<div class="paragraph">
<p>A call to the <code>subscribe</code> registers a <code>Subscription</code> that allows to cancel and, therefore, do not receive further events. Publishers can interoperate with the un-subscription and free resources once a subscriber unsubscribed from the <code>Publisher&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Implementing a <code>Subscriber&lt;T&gt;</code> requires implementing numerous methods, so lets rewrite the code to a simpler form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).doOnNext(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> s) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + s + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>);
    }
}).doOnComplete(<span class="keyword">new</span> <span class="predefined-type">Runnable</span>() {
    <span class="directive">public</span> <span class="type">void</span> run() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Completed</span><span class="delimiter">&quot;</span></span>);
    }
}).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>alternatively, even simpler by using Java 8 Lambdas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .doOnNext(s -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + s + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>))
        .doOnComplete(() -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Completed</span><span class="delimiter">&quot;</span></span>))
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can control the elements that are processed by your <code>Subscriber</code> using operators. The <code>take()</code> operator limits the number of emitted items if you are interested in the first <code>N</code> elements only.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>) <span class="comment">//</span>
        .doOnNext(s -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + s + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>))
        .doOnComplete(() -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Completed</span><span class="delimiter">&quot;</span></span>))
        .take(<span class="integer">2</span>)
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello Ben
Hello Michael
Completed</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>take</code> operator implicitly cancels its subscription from the <code>Publisher&lt;T&gt;</code> once the expected count of elements was emitted.</p>
</div>
<div class="paragraph">
<p>A subscription to a <code>Publisher&lt;T&gt;</code> can be done either by another <code>Flux</code> or a <code>Subscriber</code>. Unless you are implementing a custom <code>Publisher</code>, always use <code>Subscriber</code>. The used subscriber <code>Consumer</code> from the example above does not handle <code>Exception</code>s so once an <code>Exception</code> is thrown you will see a stack trace like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Exception in thread "main" reactor.core.Exceptions$BubblingException: java.lang.RuntimeException: Example exception
    at reactor.core.Exceptions.bubble(Exceptions.java:96)
    at reactor.core.publisher.Operators.onErrorDropped(Operators.java:296)
    at reactor.core.publisher.LambdaSubscriber.onError(LambdaSubscriber.java:117)
    ...
Caused by: java.lang.RuntimeException: Example exception
    at demos.lambda$example3Lambda$4(demos.java:87)
    at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:157)
    ... 23 more</pre>
</div>
</div>
<div class="paragraph">
<p>It is always recommended to implement an error handler right from the beginning. At a certain point, things can and will go wrong.</p>
</div>
<div class="paragraph">
<p>A fully implemented subscriber declares the <code>onCompleted</code> and <code>onError</code> methods allowing you to react to these events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).subscribe(<span class="keyword">new</span> Subscriber&lt;<span class="predefined-type">String</span>&gt;() {
    <span class="directive">public</span> <span class="type">void</span> onSubscribe(Subscription s) {
        s.request(<span class="integer">3</span>);
    }

    <span class="directive">public</span> <span class="type">void</span> onNext(<span class="predefined-type">String</span> s) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> + s + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">public</span> <span class="type">void</span> onError(<span class="predefined-type">Throwable</span> t) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">onError: </span><span class="delimiter">&quot;</span></span> + e);
    }

    <span class="directive">public</span> <span class="type">void</span> onComplete() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Completed</span><span class="delimiter">&quot;</span></span>);
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.from-push-to-pull"><a class="anchor" href="#reactive.5.from-push-to-pull"></a>4.4.6. From push to pull</h4>
<div class="paragraph">
<p>The examples from above illustrated how publishers can be set up in a not-opinionated style about blocking or non-blocking execution. A <code>Flux&lt;T&gt;</code> can be converted explicitly into an <code>Iterable&lt;T&gt;</code> or synchronized with <code>block()</code>. Avoid calling <code>block()</code> in your code as you start expressing the nature of execution inside your code. Calling <code>block()</code> removes all non-blocking advantages of the reactive chain to your application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> last = Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).last().block();
<span class="predefined-type">System</span>.out.println(last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Mark</pre>
</div>
</div>
<div class="paragraph">
<p>A blocking call can be used to synchronize the publisher chain and find back a way into the plain and well-known <code>Pull</code> pattern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).collectList().block();
<span class="predefined-type">System</span>.out.println(list);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>toList</code> operator collects all emitted elements and passes the list through the <code>BlockingPublisher&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The example prints the following line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Ben, Michael, Mark]</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.creating-flux-and-mono-using-lettuce"><a class="anchor" href="#reactive.5.creating-flux-and-mono-using-lettuce"></a>4.4.7. Creating <code>Flux</code> and <code>Mono</code> using lettuce</h4>
<div class="paragraph">
<p>There are many ways to establish publishers. You have already seen <code>just()</code>, <code>take()</code> and <code>collectList()</code>. Refer to the <a href="http://projectreactor.io/docs/">Project Reactor documentation</a> for many more methods that you can use to create <code>Flux</code> and <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>lettuce publishers can be used for initial and chaining operations. When using lettuce publishers, you will notice the non-blocking behavior. This is because all I/O and command processing are handled asynchronously using the netty EventLoop.</p>
</div>
<div class="paragraph">
<p>Connecting to Redis is insanely simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://localhost</span><span class="delimiter">&quot;</span></span>);
RedisStringReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = client.connect().reactive();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next step, obtaining a value from a key requires the <code>GET</code> operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>).subscribe(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">String</span>&gt;() {

    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> value) {
        <span class="predefined-type">System</span>.out.println(value);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, written in Java 8 lambdas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">commands
   .get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>)
   .subscribe(value -&gt; <span class="predefined-type">System</span>.out.println(value));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution is handled asynchronously, and the invoking Thread can be used to processed in processing while the operation is completed on the Netty EventLoop threads. Due to its decoupled nature, the calling method can be left before the execution of the <code>Publisher&lt;T&gt;</code> is finished.</p>
</div>
<div class="paragraph">
<p>lettuce publishers can be used within the context of chaining to load multiple keys asynchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).
        flatMap(key -&gt; commands.get(key)).
        subscribe(value -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.hot-and-cold-publishers"><a class="anchor" href="#reactive.5.hot-and-cold-publishers"></a>4.4.8. Hot and Cold Publishers</h4>
<div class="paragraph">
<p>There is a distinction between Publishers that was not covered yet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A cold Publishers waits for a subscription until it emits values and does this freshly for every subscriber.</p>
</li>
<li>
<p>A hot Publishers begins emitting values upfront and presents them to every subscriber subsequently.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All Publishers returned from the Redis Standalone, Redis Cluster, and Redis Sentinel API are cold, meaning that no I/O happens until they are subscribed to. As such a subscriber is guaranteed to see the whole sequence from the beginning. So just creating a Publisher will not cause any network I/O thus creating and discarding Publishers is cheap. Publishers created for a Publish/Subscribe emit <code>PatternMessage</code>s and <code>ChannelMessage</code>s once they are subscribed to. Publishers guarantee however to emit all items from the beginning until their end. While this is true for Publish/Subscribe publishers, the nature of subscribing to a Channel/Pattern allows missed messages due to its subscription nature and less to the Hot/Cold distinction of publishers.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.transforming-publishers"><a class="anchor" href="#reactive.5.transforming-publishers"></a>4.4.9. Transforming publishers</h4>
<div class="paragraph">
<p>Publishers can transform the emitted values in various ways. One of the most basic transformations is <code>flatMap()</code> which you have seen from the examples above that converts the incoming value into a different one. Another one is <code>map()</code>. The difference between <code>map()</code> and <code>flatMap()</code> is that <code>flatMap()</code> allows you to do those transformations with <code>Publisher&lt;T&gt;</code> calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .flatMap(commands::get)
        .flatMap(value -&gt; commands.rpush(<span class="string"><span class="delimiter">&quot;</span><span class="content">result</span><span class="delimiter">&quot;</span></span>, value))
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first <code>flatMap()</code> function is used to retrieve a value and the second <code>flatMap()</code> function appends the value to a Redis list named <code>result</code>. The <code>flatMap()</code> function returns a Publisher whereas the normal map just returns <code>&lt;T&gt;</code>. You will use <code>flatMap()</code> a lot when dealing with flows like this, you&#8217;ll become good friends.</p>
</div>
<div class="paragraph">
<p>An aggregation of values can be achieved using the <code>reduce()</code> transformation. It applies a function to each value emitted by a <code>Publisher&lt;T&gt;</code>, sequentially and emits each successive value. We can use it to aggregate values, to count the number of elements in multiple Redis sets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .flatMap(commands::scard)
        .reduce((sum, current) -&gt; sum + current)
        .subscribe(result -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Number of elements in sets: </span><span class="delimiter">&quot;</span></span> + result));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The aggregation function of <code>reduce()</code> is applied on each emitted value, so three times in the example above. If you want to get the last value, which denotes the final result containing the number of elements in all Redis sets, apply the <code>last()</code> transformation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .flatMap(commands::scard)
        .reduce((sum, current) -&gt; sum + current)
        .last()
        .subscribe(result -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Number of elements in sets: </span><span class="delimiter">&quot;</span></span> + result));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s take a look at grouping emitted items. The following example emits three items and groups them by the beginning character.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
    .groupBy(key -&gt; key.substring(<span class="integer">0</span>, <span class="integer">1</span>))
    .subscribe(
        groupedFlux -&gt; {
            groupedFlux.collectList().subscribe(list -&gt; {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">First character: </span><span class="delimiter">&quot;</span></span> + groupedFlux.key() + <span class="string"><span class="delimiter">&quot;</span><span class="content">, elements: </span><span class="delimiter">&quot;</span></span> + list);
            });
        }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>First character: B, elements: [Ben]
First character: M, elements: [Michael, Mark]</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.absent-values"><a class="anchor" href="#reactive.5.absent-values"></a>4.4.10. Absent values</h4>
<div class="paragraph">
<p>The presence and absence of values is an essential part of reactive programming. Traditional approaches consider <code>null</code> as an absence of a particular value. With Java 8, <code>Optional&lt;T&gt;</code> was introduced to encapsulate nullability. Reactive Streams prohibits the use of <code>null</code> values.</p>
</div>
<div class="paragraph">
<p>In the scope of Redis, an absent value is an empty list, a non-existent key or any other empty data structure.
Reactive programming discourages the use of <code>null</code> as value. The reactive answer to absent values is just not emitting any value that is possible due the <code>0</code> to <code>N</code> nature of <code>Publisher&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Suppose we have the keys <code>Ben</code> and <code>Michael</code> set each to the value <code>value</code>. We query those and another, absent key with the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .flatMap(commands::get)
        .doOnNext(value -&gt; <span class="predefined-type">System</span>.out.println(value))
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>value
value</pre>
</div>
</div>
<div class="paragraph">
<p>The output is just two values. The <code>GET</code> to the absent key <code>Mark</code> does not emit a value.</p>
</div>
<div class="paragraph">
<p>The reactive API provides operators to work with empty results when you require a value. You can use one of the following operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>defaultIfEmpty</code>: Emit a default value if the <code>Publisher&lt;T&gt;</code> did not emit any value at all</p>
</li>
<li>
<p><code>switchIfEmpty</code>: Switch to a fallback <code>Publisher&lt;T&gt;</code> to emit values</p>
</li>
<li>
<p><code>Flux.hasElements</code>/<code>Flux.hasElement</code>: Emit a <code>Mono&lt;Boolean&gt;</code> that contains a flag whether the original <code>Publisher&lt;T&gt;</code> is empty</p>
</li>
<li>
<p><code>next</code>/<code>last</code>/<code>elementAt</code>: Positional operators to retrieve the first/last/<code>N</code>th element or emit a default value</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.filtering-items"><a class="anchor" href="#reactive.5.filtering-items"></a>4.4.11. Filtering items</h4>
<div class="paragraph">
<p>The values emitted by a <code>Publisher&lt;T&gt;</code> can be filtered in case you need only specific results. Filtering does not change the emitted values itself. Filters affect how many items and at which point (and if at all) they are emitted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .filter(s -&gt; s.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>))
        .flatMap(commands::get)
        .subscribe(value -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code will fetch only the keys <code>Michael</code> and <code>Mark</code> but not <code>Ben</code>. The filter criteria are whether the <code>key</code> starts with a <code>M</code>.</p>
</div>
<div class="paragraph">
<p>You already met the <code>last()</code> filter to retrieve the last value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .last()
        .subscribe(value -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value));</code></pre>
</div>
</div>
<div class="paragraph">
<p>the extended variant of <code>last()</code> allows you to take the last <code>N</code> values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .takeLast(<span class="integer">3</span>)
        .subscribe(value -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example from above takes the last <code>2</code> values.</p>
</div>
<div class="paragraph">
<p>The opposite to <code>next()</code> is the <code>first()</code> filter that is used to retrieve the next value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .next()
        .subscribe(value -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Got value: </span><span class="delimiter">&quot;</span></span> + value));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.error-handling"><a class="anchor" href="#reactive.5.error-handling"></a>4.4.12. Error handling</h4>
<div class="paragraph">
<p>Error handling is an indispensable component of every real world application and should to be considered from the beginning on. Project Reactor provides several mechanisms to deal with errors.</p>
</div>
<div class="paragraph">
<p>In general, you want to react in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Return a default value instead</p>
</li>
<li>
<p>Use a backup publisher</p>
</li>
<li>
<p>Retry the Publisher (immediately or with delay)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code falls back to a default value after it throws an exception at the first emitted item:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .doOnNext(value -&gt; {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Takes way too long</span><span class="delimiter">&quot;</span></span>);
        })
        .onErrorReturn(<span class="string"><span class="delimiter">&quot;</span><span class="content">Default value</span><span class="delimiter">&quot;</span></span>)
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use a backup <code>Publisher&lt;T&gt;</code> which will be called if the first one fails.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .doOnNext(value -&gt; {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Takes way too long</span><span class="delimiter">&quot;</span></span>);
        })
        .switchOnError(commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">Default Key</span><span class="delimiter">&quot;</span></span>))
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to retry the publisher by re-subscribing. Re-subscribing can be done as soon as possible, or with a wait interval, which is preferred when external resources are involved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .flatMap(commands::get)
        .retry()
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the following code if you want to retry with backoff:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .doOnNext(v -&gt; {
            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="predefined-type">Random</span>().nextInt(<span class="integer">10</span>) + <span class="integer">1</span> == <span class="integer">5</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Boo!</span><span class="delimiter">&quot;</span></span>);
            }
        })
        .doOnSubscribe(subscription -&gt;
        {
            <span class="predefined-type">System</span>.out.println(subscription);
        })
        .retryWhen(throwableFlux -&gt; Flux.range(<span class="integer">1</span>, <span class="integer">5</span>)
                .flatMap(i -&gt; {
                    <span class="predefined-type">System</span>.out.println(i);
                    <span class="keyword">return</span> Flux.just(i)
                            .delay(<span class="predefined-type">Duration</span>.of(i, ChronoUnit.SECONDS));
                }))
        .blockLast();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attempts get passed into the <code>retryWhen()</code> method delayed with the number of seconds to wait. The delay method is used to complete once its timer is done.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.schedulers-and-threads"><a class="anchor" href="#reactive.5.schedulers-and-threads"></a>4.4.13. Schedulers and threads</h4>
<div class="paragraph">
<p>Schedulers in Project Reactor are used to instruct multi-threading. Some operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.</p>
</div>
<div class="paragraph">
<p>Project Reactor ships with a set of preconfigured Schedulers, which are all accessible through the <code>Schedulers</code> class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Schedulers.parallel(): Executes the computational work such as event-loops and callback processing.</p>
</li>
<li>
<p>Schedulers.immediate(): Executes the work immediately in the current thread</p>
</li>
<li>
<p>Schedulers.elastic(): Executes the I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed</p>
</li>
<li>
<p>Schedulers.newSingle(): Executes the work on a new thread</p>
</li>
<li>
<p>Schedulers.fromExecutor(): Create a scheduler from a <code>java.util.concurrent.Executor</code></p>
</li>
<li>
<p>Schedulers.timer(): Create or reuse a hash-wheel based TimedScheduler with a resolution of 50ms.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Do not use the computational scheduler for I/O.</p>
</div>
<div class="paragraph">
<p>Publishers can be executed by a scheduler in the following different ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using an operator that makes use of a scheduler</p>
</li>
<li>
<p>Explicitly by passing the Scheduler to such an operator</p>
</li>
<li>
<p>By using <code>subscribeOn(Scheduler)</code></p>
</li>
<li>
<p>By using <code>publishOn(Scheduler)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Operators like <code>buffer</code>, <code>replay</code>, <code>skip</code>, <code>delay</code>, <code>parallel</code>, and so forth use a Scheduler by default if not instructed otherwise.</p>
</div>
<div class="paragraph">
<p>All of the listed operators allow you to pass in a custom scheduler if needed. Sticking most of the time with the defaults is a good idea.</p>
</div>
<div class="paragraph">
<p>If you want the subscribe chain to be executed on a specific scheduler, you use the <code>subscribeOn()</code> operator. The code is executed on the main thread without a scheduler set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).flatMap(key -&gt; {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 1: </span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span> Flux.just(key);
        }
).flatMap(value -&gt; {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 2: </span><span class="delimiter">&quot;</span></span> + value + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span> Flux.just(value);
        }
).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map 1: Ben (main)
Map 2: Ben (main)
Map 1: Michael (main)
Map 2: Michael (main)
Map 1: Mark (main)
Map 2: Mark (main)</pre>
</div>
</div>
<div class="paragraph">
<p>This example shows the <code>subscribeOn()</code> method added to the flow (it does not matter where you add it):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).flatMap(key -&gt; {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 1: </span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span> Flux.just(key);
        }
).flatMap(value -&gt; {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 2: </span><span class="delimiter">&quot;</span></span> + value + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span> Flux.just(value);
        }
).subscribeOn(Schedulers.parallel()).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the example shows the effect of <code>subscribeOn()</code>. You can see that the Publisher is executed on the same thread, but on the computation thread pool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map 1: Ben (parallel-1)
Map 2: Ben (parallel-1)
Map 1: Michael (parallel-1)
Map 2: Michael (parallel-1)
Map 1: Mark (parallel-1)
Map 2: Mark (parallel-1)</pre>
</div>
</div>
<div class="paragraph">
<p>If you apply the same code to lettuce, you will notice a difference in the threads on which the second <code>flatMap()</code> is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).flatMap(key -&gt; {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 1: </span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> commands.set(key, key);
}).flatMap(value -&gt; {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 2: </span><span class="delimiter">&quot;</span></span> + value + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> Flux.just(value);
}).subscribeOn(Schedulers.parallel()).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example prints the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map 1: Ben (parallel-1)
Map 1: Michael (parallel-1)
Map 1: Mark (parallel-1)
Map 2: OK (lettuce-nioEventLoop-3-1)
Map 2: OK (lettuce-nioEventLoop-3-1)
Map 2: OK (lettuce-nioEventLoop-3-1)</pre>
</div>
</div>
<div class="paragraph">
<p>Two things differ from the standalone examples:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The values are set rather concurrently than sequentially</p>
</li>
<li>
<p>The second <code>flatMap()</code> transformation prints the netty EventLoop thread name</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is because lettuce publishers are executed and completed on the netty EventLoop threads by default.</p>
</div>
<div class="paragraph">
<p><code>publishOn</code> instructs an Publisher to call its observer’s <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods on a particular Scheduler. Here, the order matters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>).flatMap(key -&gt; {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 1: </span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> commands.set(key, key);
}).publishOn(Schedulers.parallel()).flatMap(value -&gt; {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Map 2: </span><span class="delimiter">&quot;</span></span> + value + <span class="string"><span class="delimiter">&quot;</span><span class="content"> (</span><span class="delimiter">&quot;</span></span> + <span class="predefined-type">Thread</span>.currentThread().getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> Flux.just(value);
}).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything before the <code>publishOn()</code> call is executed in main, everything below in the scheduler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Map 1: Ben (main)
Map 1: Michael (main)
Map 1: Mark (main)
Map 2: OK (parallel-1)
Map 2: OK (parallel-1)
Map 2: OK (parallel-1)</pre>
</div>
</div>
<div class="paragraph">
<p>Schedulers allow direct scheduling of operations. Refer to the <a href="https://projectreactor.io/core/docs/api/reactor/core/scheduler/Schedulers.html">Project Reactor documentation</a> for further information.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.5.redis-transactions"><a class="anchor" href="#reactive.5.redis-transactions"></a>4.4.14. Redis Transactions</h4>
<div class="paragraph">
<p>lettuce provides a convenient way to use Redis Transactions in a reactive way. Commands that should be executed within a transaction can be executed after the <code>MULTI</code> command was executed. Functional chaining allows to execute commands within a closure, and each command receives its appropriate response. A cumulative response is also returned with <code>TransactionResult</code> in response to <code>EXEC</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="Transactions#transactions-using-the-reactive-api">Transactions</a> for further details.</p>
</div>
<div class="sect4">
<h5 id="reactive.5.other-examples"><a class="anchor" href="#reactive.5.other-examples"></a>Other examples</h5>
<div class="paragraph">
<p><strong>Blocking example</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisStringReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; reactive = client.connect().reactive();
Mono&lt;<span class="predefined-type">String</span>&gt; set = reactive.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
set.block();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Non-blocking example</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisStringReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; reactive = client.connect().reactive();
Mono&lt;<span class="predefined-type">String</span>&gt; set = reactive.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
set.subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Functional chaining</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisStringReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; reactive = client.connect().reactive();
Flux.just(<span class="string"><span class="delimiter">&quot;</span><span class="content">Ben</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Michael</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mark</span><span class="delimiter">&quot;</span></span>)
        .flatMap(key -&gt; commands.sadd(<span class="string"><span class="delimiter">&quot;</span><span class="content">seen</span><span class="delimiter">&quot;</span></span>, key))
        .flatMap(value -&gt; commands.randomkey())
        .flatMap(commands::type)
        .doOnNext(<span class="predefined-type">System</span>.out::println).subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Redis Transaction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>RedisReactiveCommands&lt;String, String&gt; reactive = client.connect().reactive();

reactive.multi().doOnSuccess(s -&gt; {
    reactive.set("key", "1").doOnNext(s1 -&gt; System.out.println(s1)).subscribe();
    reactive.incr("key").doOnNext(s1 -&gt; System.out.println(s1)).subscribe();
}).flatMap(s -&gt; reactive.exec())
        .doOnNext(transactionResults -&gt; System.out.println(transactionResults.wasRolledBack()))
        .subscribe();</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_publishsubscribe"><a class="anchor" href="#_publishsubscribe"></a>4.5. Publish/Subscribe</h3>
<div class="paragraph">
<p>Lettuce provides support for Publish/Subscribe on Redis Standalone and
Redis Cluster connections. The connection is notified on
message/subscribed/unsubscribed events after subscribing to channels or
patterns. <a href="#basic-usage">Synchronous</a>, <a href="#asynchronous-api">asynchronous</a> and <a href="#reactive-api">reactive</a> API&#8217;s are provided to interact with Redis Publish/Subscribe features.</p>
</div>
<div class="sect3">
<h4 id="pubsub.subscribing"><a class="anchor" href="#pubsub.subscribing"></a>4.5.1. Subscribing</h4>
<div class="paragraph">
<p>A connection can notify multiple listeners that implement
<code>RedisPubSubListener</code> (Lettuce provides a <code>RedisPubSubAdapter</code> for
convenience). All listener registrations are kept within the
<code>StatefulRedisPubSubConnection</code>/<code>StatefulRedisClusterConnection</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Synchronous subscription</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisPubSubConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connectPubSub()
connection.addListener(<span class="keyword">new</span> RedisPubSubListener&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;() { ... })

RedisPubSubCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; sync = connection.sync();
sync.subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">channel</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// application flow continues</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 25. Asynchronous subscription</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisPubSubConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connectPubSub()
connection.addListener(<span class="keyword">new</span> RedisPubSubListener&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;() { ... })

RedisPubSubAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = connection.async();
RedisFuture&lt;<span class="predefined-type">Void</span>&gt; future = async.subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">channel</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// application flow continues</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pubsub.reactive-api"><a class="anchor" href="#pubsub.reactive-api"></a>4.5.2. Reactive API</h4>
<div class="paragraph">
<p>The reactive API provides hot <code>Observable</code>s to listen on
<code>ChannelMessage</code>s and <code>PatternMessage</code>s. The <code>Observable</code>s receive all
inbound messages. You can do filtering using the observable chain if you
need to filter out the interesting ones, The <code>Observable</code> stops
triggering events when the subscriber unsubscribes from it.</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Reactive subscription</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisPubSubConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connectPubSub()

RedisPubSubReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; reactive = connection.reactive();
reactive.subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">channel</span><span class="delimiter">&quot;</span></span>).subscribe();

reactive.observeChannels().doOnNext(patternMessage -&gt; {...}).subscribe()

<span class="comment">// application flow continues</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pubsub.cluster"><a class="anchor" href="#pubsub.cluster"></a>4.5.3. Redis Cluster</h4>
<div class="paragraph">
<p>Redis Cluster support Publish/Subscribe but requires some attention in general. User-space Pub/Sub messages (Calling <code>PUBLISH</code>) are broadcasted across the whole cluster regardless of subscriptions to particular channels/patterns. This behavior allows connecting to an arbitrary cluster node and registering a subscription. The client isn&#8217;t required to connect to the node where messages were published.</p>
</div>
<div class="paragraph">
<p>A cluster-aware Pub/Sub connection is provided by <code>RedisClusterClient.connectPubSub()</code> allowing to listen for cluster reconfiguration and reconnect if the topology changes.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Redis Cluster Publish/Subscribe</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisClusterPubSubConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = clusterClient.connectPubSub()
connection.addListener(<span class="keyword">new</span> RedisPubSubListener&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;() { ... })

RedisPubSubCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; sync = connection.sync();
sync.subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">channel</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Redis Cluster also makes a distinction between user-space and key-space messages. Key-space notifications (Pub/Sub messages for key-activity) stay node-local and are not broadcasted across the Redis Cluster. A notification about, e.g. an expiring key, stays local to the node on which the key expired.</p>
</div>
<div class="paragraph">
<p>Clients that are interested in keyspace notifications must subscribe to the appropriate node (or nodes) to receive these notifications. You can either use <code>RedisClient.connectPubSub()</code> to establish Pub/Sub connections to the individual nodes or use <code>RedisClusterClient</code>'s message propagation and NodeSelection API to get a managed set of connections.</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. Redis Cluster Publish/Subscribe with node message propagation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisClusterPubSubConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = clusterClient.connectPubSub()
connection.addListener(<span class="keyword">new</span> RedisClusterPubSubListener&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;() { ... })
connection.setNodeMessagePropagation(<span class="predefined-constant">true</span>);

RedisPubSubCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; sync = connection.sync();
sync.masters().commands().subscribe(<span class="string"><span class="delimiter">&quot;</span><span class="content">__keyspace@0__:*</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There are two things to pay special attention to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Replication: Keys replicated to replica nodes, especially considering expiry, generate keyspace events on all nodes holding the key. If a key expires and it is replicated, it will expire on the master and all replicas. Each Redis server will emit keyspace events. Subscribing to non-master nodes, therefore, will let your application see multiple events of the same type for the same key because of Redis distributed nature.</p>
</li>
<li>
<p>Topology Changes: Subscriptions are issued either by using the NodeSelection API or by calling <code>subscribe(…)</code> on the individual cluster node connections. Subscription registrations are not propagated to new nodes that are added on a topology change.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transactionsmulti"><a class="anchor" href="#_transactionsmulti"></a>4.6. Transactions/Multi</h3>
<div class="paragraph">
<p>Transactions allow the execution of a group of commands in a single step. Transactions can be controlled using <code>WATCH</code>, <code>UNWATCH</code>, <code>EXEC</code>, <code>MULTI</code> and <code>DISCARD</code> commands. Synchronous, asynchronous, reactive and cluster API&#8217;s allow the use of transactions.</p>
</div>
<div class="paragraph">
<p>Redis responds to commands invoked during a transaction with a with <code>QUEUED</code> response. The response related to the execution of the command is received at the moment the <code>EXEC</code> command is processed, and the transaction is executed. The particular APIs behave in different ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Synchronous: Invocations to the commands return <code>null</code> while they are invoked within a transaction. The <code>MULTI</code> command carries the response of the particular commands.</p>
</li>
<li>
<p>Asynchronous: The futures receive their response at the moment the <code>EXEC</code> command is processed. This happens while the <code>EXEC</code> response is received.</p>
</li>
<li>
<p>Reactive: An <code>Obvervable&lt;T&gt;</code> triggers <code>onNext</code>/<code>onCompleted</code> at the moment the <code>EXEC</code> command is processed. This happens while the <code>EXEC</code> response is received.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As soon as you&#8217;re within a transaction, you won&#8217;t receive any responses on triggering the commands</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">redis.multi() == <span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>
redis.set(key, value) == <span class="predefined-constant">null</span>
redis.exec() == list(<span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll receive the transactional response when calling <code>exec()</code> on the end of your transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">redis.multi() == <span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>
redis.set(key1, value) == <span class="predefined-constant">null</span>
redis.set(key2, value) == <span class="predefined-constant">null</span>
redis.exec() == list(<span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">OK</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="transactions-using-the-asynchronous-api"><a class="anchor" href="#transactions-using-the-asynchronous-api"></a>4.6.1. Transactions using the asynchronous API</h4>
<div class="paragraph">
<p>Asynchronous use of Redis transactions is very similar to non-transactional use. The asynchronous API returns <code>RedisFuture</code> instances that eventually complete and they are handles to a future result. Regular commands complete as soon as Redis sends a response. Transactional commands complete as soon as the <code>EXEC</code> result is received.</p>
</div>
<div class="paragraph">
<p>Each command is completed individually with its own result so users of <code>RedisFuture</code> will see no difference between transactional and non-transactional <code>RedisFuture</code> completion. That said, transactional command results are available twice: Once via <code>RedisFuture</code> of the command and once through <code>List&lt;Object&gt;</code> (<code>TransactionResult</code> since Lettuce 5) of the <code>EXEC</code> command future.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = client.connect().async();

RedisFuture&lt;<span class="predefined-type">String</span>&gt; multi = async.multi();

RedisFuture&lt;<span class="predefined-type">String</span>&gt; set = async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);

RedisFuture&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt;&gt; exec = async.exec();

<span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt; objects = exec.get();
<span class="predefined-type">String</span> setResult = set.get();

objects.get(<span class="integer">0</span>) == setResult</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactions-using-the-reactive-api"><a class="anchor" href="#transactions-using-the-reactive-api"></a>4.6.2. Transactions using the reactive API</h4>
<div class="paragraph">
<p>The reactive API can be used to execute multiple commands in a single step. The nature of the reactive API encourages nesting of commands. It is essential to understand the time at which an <code>Observable&lt;T&gt;</code> emits a value when working with transactions. Redis responds with <code>QUEUED</code> to commands invoked during a transaction. The response related to the execution of the command is received at the moment the <code>EXEC</code> command is processed, and the transaction is executed. Subsequent calls in the processing chain are executed after the transactional end. The following code starts a transaction, executes two commands within the transaction and finally executes the transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; reactive = client.connect().reactive();
reactive.multi().subscribe(multiResponse -&gt; {
    reactive.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>).subscribe();
    reactive.incr(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>).subscribe();
    reactive.exec().subscribe();
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactions-on-clustered-connections"><a class="anchor" href="#transactions-on-clustered-connections"></a>4.6.3. Transactions on clustered connections</h4>
<div class="paragraph">
<p>Clustered connections perform a routing by default. This means, that you can&#8217;t be really sure, on which host your command is executed. So if you are working in a clustered environment, use rather a regular connection to your node, since then you&#8217;ll bound to that node knowing which hash slots are handled by it.</p>
</div>
</div>
<div class="sect3">
<h4 id="examples"><a class="anchor" href="#examples"></a>4.6.4. Examples</h4>
<div class="paragraph">
<p><strong>Multi with executing multiple commands</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">redis.multi();

redis.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>);
redis.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>);
redis.mget(<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span>);
redis.llen(key);

redis.exec(); <span class="comment">// result: list(&quot;OK&quot;, &quot;OK&quot;, list(&quot;1&quot;, &quot;2&quot;), 0L)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mult executing multiple asynchronous commands</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">redis.multi();

RedisFuture&lt;<span class="predefined-type">String</span>&gt; set1 = redis.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>);
RedisFuture&lt;<span class="predefined-type">String</span>&gt; set2 = redis.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>);
RedisFuture&lt;<span class="predefined-type">String</span>&gt; mget = redis.mget(<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span>);
RedisFuture&lt;<span class="predefined-type">Long</span>&gt; llen = mgetredis.llen(key);


set1.thenAccept(value -&gt; <span class="error">…</span>); <span class="comment">// OK</span>
set2.thenAccept(value -&gt; <span class="error">…</span>); <span class="comment">// OK</span>

RedisFuture&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span>&gt;&gt; exec = redis.exec(); <span class="comment">// result: list(&quot;OK&quot;, &quot;OK&quot;, list(&quot;1&quot;, &quot;2&quot;), 0L)</span>

mget.get(); <span class="comment">// list(&quot;1&quot;, &quot;2&quot;)</span>
llen.thenAccept(value -&gt; <span class="error">…</span>); <span class="comment">// 0L</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Using WATCH</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">redis.watch(key);

RedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; redis2 = client.connect();
redis2.set(key, value + <span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>);
redis2.close();

redis.multi();
redis.append(key, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>);
redis.exec()); <span class="comment">// result is a empty list because of the changed key</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ha-sharding"><a class="anchor" href="#ha-sharding"></a>5. High-Availability and Sharding</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="master-replica"><a class="anchor" href="#master-replica"></a>5.1. Master/Replica</h3>
<div class="paragraph">
<p>Redis can increase availability and read throughput by using replication. Lettuce provides dedicated Master/Replica support since 4.2 for topologies and ReadFrom-Settings.</p>
</div>
<div class="paragraph">
<p>Redis Master/Replica can be run standalone or together with Redis Sentinel, which provides automated failover and master promotion. Failover and master promotion is supported in Lettuce already since version 3.1 for master connections.</p>
</div>
<div class="paragraph">
<p>Connections can be obtained from the <code>MasterSlave</code> connection provider by supplying the client, Codec, and one or multiple RedisURIs.</p>
</div>
<div class="sect3">
<h4 id="masterreplica.redis-sentinel"><a class="anchor" href="#masterreplica.redis-sentinel"></a>5.1.1. Redis Sentinel</h4>
<div class="paragraph">
<p>Master/Replica using <a href="#redis-sentinel">Redis Sentinel</a> uses Redis Sentinel as registry and notification source for topology events. Details about the master and its replicas are obtained from <a href="#redis-sentinel">Redis Sentinel</a>. Lettuce subscribes to <a href="#redis-sentinel">Redis Sentinel</a> events for notifications to all supplied Sentinels.</p>
</div>
</div>
<div class="sect3">
<h4 id="masterreplica.standalone-masterreplica"><a class="anchor" href="#masterreplica.standalone-masterreplica"></a>5.1.2. Standalone Master/Replica</h4>
<div class="paragraph">
<p>Running a Standalone Master/Replica setup required one seed address to establish a Redis connection. Providing one <code>RedisURI</code> will discover other nodes which belong to the Master/Replica setup and use the discovered addresses for connections. The initial URI can point either to a master or a replica node.</p>
</div>
</div>
<div class="sect3">
<h4 id="masterreplica.static-masterreplica-with-predefined-node-addresses"><a class="anchor" href="#masterreplica.static-masterreplica-with-predefined-node-addresses"></a>5.1.3. Static Master/Replica with predefined node addresses</h4>
<div class="paragraph">
<p>In some cases, topology discovery shouldn&#8217;t be enabled, or the discovered Redis addresses are not suited for connections. AWS ElastiCache falls into this category. Lettuce allows to specify one or more Redis addresses as <code>List</code> and predefine the node topology. Master/Replica URIs will be treated in this case as static topology, and no additional hosts are discovered in such case. Redis Standalone Master/Replica will discover the roles of the supplied <code>RedisURI</code>s and issue commands to the appropriate node.</p>
</div>
</div>
<div class="sect3">
<h4 id="masterreplica.topology-discovery"><a class="anchor" href="#masterreplica.topology-discovery"></a>5.1.4. Topology discovery</h4>
<div class="paragraph">
<p>Master-Replica topologies are either static or semi-static. Redis Standalone instances with attached replicas provide no failover/HA mechanism. Redis Sentinel managed instances are controlled by Redis Sentinel and allow failover (which include master promotion). The <code>MasterSlave</code> API supports both mechanisms. The topology is provided by a <code>TopologyProvider</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MasterSlaveTopologyProvider</code>: Dynamic topology lookup using the <code>INFO REPLICATION</code> output. Replicas are listed as replicaN=&#8230;&#8203; entries. The initial connection can either point to a master or a replica, and the topology provider will discover nodes. The connection needs to be re-established outside of Lettuce in a case of a Master/Replica failover or topology changes.</p>
</li>
<li>
<p><code>StaticMasterSlaveTopologyProvider</code>: Topology is defined by the list of URIs and the ROLE output. MasterSlave uses only the supplied nodes and won&#8217;t discover additional nodes in the setup. The connection needs to be re-established outside of Lettuce in case of a Master/Replica failover or topology changes.</p>
</li>
<li>
<p><code>SentinelTopologyProvider</code>: Dynamic topology lookup using the Redis Sentinel API. In particular, <code>SENTINEL MASTER</code> and <code>SENTINEL REPLICAS</code> output. Master/Replica failover is handled by Lettuce.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="masterreplica.topology-updates"><a class="anchor" href="#masterreplica.topology-updates"></a>5.1.5. Topology Updates</h4>
<div class="ulist">
<ul>
<li>
<p>Standalone Master/Replica: Performs a one-time topology lookup which remains static afterward</p>
</li>
<li>
<p>Redis Sentinel: Subscribes to all Sentinels and listens for Pub/Sub messages to trigger topology refreshing</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="masterreplica.transactions"><a class="anchor" href="#masterreplica.transactions"></a>Transactions</h5>
<div class="paragraph">
<p>Since version 5.1, transactions and commands during a transaction are routed to the master node to ensure atomic transaction execution on a single node. Transactions can contain read- and write-operations so the driver cannot decide upfront which node can be used to run the actual transaction.</p>
</div>
</div>
<div class="sect4">
<h5 id="masterreplica.examples"><a class="anchor" href="#masterreplica.examples"></a>Examples</h5>
<div class="exampleblock">
<div class="title">Example 29. Redis Standalone Master/Replica</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient redisClient = RedisClient.create();

StatefulRedisMasterSlaveConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = MasterSlave.connect(redisClient, <span class="keyword">new</span> Utf8StringCodec(),
        RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://localhost</span><span class="delimiter">&quot;</span></span>));
connection.setReadFrom(ReadFrom.MASTER_PREFERRED);

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Connected to Redis</span><span class="delimiter">&quot;</span></span>);

connection.close();
redisClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 30. Redis Sentinel</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient redisClient = RedisClient.create();

StatefulRedisMasterSlaveConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = MasterSlave.connect(redisClient, <span class="keyword">new</span> Utf8StringCodec(),
        RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis-sentinel://localhost:26379,localhost:26380/0#mymaster</span><span class="delimiter">&quot;</span></span>));
connection.setReadFrom(ReadFrom.MASTER_PREFERRED);

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Connected to Redis</span><span class="delimiter">&quot;</span></span>);

connection.close();
redisClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 31. AWS ElastiCache Cluster</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient redisClient = RedisClient.create();

<span class="predefined-type">List</span>&lt;RedisURI&gt; nodes = <span class="predefined-type">Arrays</span>.asList(RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://host1</span><span class="delimiter">&quot;</span></span>),
        RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://host2</span><span class="delimiter">&quot;</span></span>),
        RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://host3</span><span class="delimiter">&quot;</span></span>));

StatefulRedisMasterSlaveConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = MasterSlave
        .connect(redisClient, <span class="keyword">new</span> Utf8StringCodec(), nodes);
connection.setReadFrom(ReadFrom.MASTER_PREFERRED);

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Connected to Redis</span><span class="delimiter">&quot;</span></span>);

connection.close();
redisClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis-sentinel"><a class="anchor" href="#redis-sentinel"></a>5.2. Redis Sentinel</h3>
<div class="paragraph">
<p>When using lettuce, you can interact with Redis Sentinel and Redis Sentinel-managed nodes in multiple ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#direct-connection-redis-sentinel-nodes">Direct connection to Redis Sentinel</a>, for issuing Redis Sentinel commands</p>
</li>
<li>
<p>Using Redis Sentinel to <a href="#sentinel.redis-discovery-using-redis-sentinel">connect to a master</a></p>
</li>
<li>
<p>Using Redis Sentinel to connect to masters and replicas through the <a href="#master-slave">[master-slave]</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In both cases, you need to supply a <code>RedisURI</code> since the Redis Sentinel integration supports multiple Sentinel hosts to provide high availability.</p>
</div>
<div class="paragraph">
<p>Please note: Redis Sentinel (lettuce 3.x) integration provides only asynchronous connections and no connection pooling.</p>
</div>
<div class="sect3">
<h4 id="direct-connection-redis-sentinel-nodes"><a class="anchor" href="#direct-connection-redis-sentinel-nodes"></a>5.2.1. Direct connection Redis Sentinel nodes</h4>
<div class="paragraph">
<p>Lettuce exposes an API to interact with Redis Sentinel nodes directly. This is useful for performing administrative tasks using lettuce. You can monitor new masters, query master addresses, replicas and much more. A connection to a Redis Sentinel node is established by <code>RedisClient.connectSentinel()</code>. Use a <a href="Pub-Sub-(4.0)">Publish/Subscribe connection</a> to subscribe to Sentinel events.</p>
</div>
</div>
<div class="sect3">
<h4 id="sentinel.redis-discovery-using-redis-sentinel"><a class="anchor" href="#sentinel.redis-discovery-using-redis-sentinel"></a>5.2.2. Redis discovery using Redis Sentinel</h4>
<div class="paragraph">
<p>One or more Redis Sentinels can monitor Redis instances . These Redis instances are usually operated together with a replica of the Redis instance. Once the master goes down, the replica is promoted to a master. Once a master instance is not reachable anymore, the failover process is started by the Redis Sentinels. Usually, the client connection is terminated. The disconnect can result in any of the following options:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The master comes back: The connection is restored to the Redis instance</p>
</li>
<li>
<p>A replica is promoted to a master: lettuce performs an address lookup using the <code>masterId</code>. As soon as the Redis Sentinel provides an address the connection is restored to the new Redis instance</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Read more at <a href="http://redis.io/topics/sentinel" class="bare">http://redis.io/topics/sentinel</a></p>
</div>
</div>
<div class="sect3">
<h4 id="sentinel.examples"><a class="anchor" href="#sentinel.examples"></a>5.2.3. Examples</h4>
<div class="exampleblock">
<div class="title">Example 32. Redis Sentinel node connection</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://sentinelhost1:26379</span><span class="delimiter">&quot;</span></span>);
RedisClient client = <span class="keyword">new</span> RedisClient(redisUri);

RedisSentinelAsyncConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;  connection = client.connectSentinelAsync();

<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; map = connection.master(<span class="string"><span class="delimiter">&quot;</span><span class="content">mymaster</span><span class="delimiter">&quot;</span></span>).get();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 33. Redis master discovery</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.sentinel(<span class="string"><span class="delimiter">&quot;</span><span class="content">sentinelhost1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">mymaster</span><span class="delimiter">&quot;</span></span>).withSentinel(<span class="string"><span class="delimiter">&quot;</span><span class="content">sentinelhost2</span><span class="delimiter">&quot;</span></span>).build();
RedisClient client = RedisClient.create(redisUri);

RedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connect();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Every time you connect to a Redis instance using Redis Sentinel, the Redis master is looked up using a new connection to a Redis Sentinel. This can be time-consuming, especially when multiple Redis Sentinels are used and one or more of them are not reachable.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis-cluster"><a class="anchor" href="#redis-cluster"></a>5.3. Redis Cluster</h3>
<div class="paragraph">
<p>Lettuce supports Redis Cluster with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Support of all <code>CLUSTER</code> commands</p>
</li>
<li>
<p>Command routing based on the hash slot of the commands' key</p>
</li>
<li>
<p>High-level abstraction for selected cluster commands</p>
</li>
<li>
<p>Execution of commands on multiple cluster nodes</p>
</li>
<li>
<p><code>MOVED</code> and <code>ASK</code> redirection handling</p>
</li>
<li>
<p>Obtaining direct connections to cluster nodes by slot and host/port (since 3.3)</p>
</li>
<li>
<p>SSL and authentication (since 4.2)</p>
</li>
<li>
<p>Periodic and adaptive cluster topology updates</p>
</li>
<li>
<p>Publish/Subscribe</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Connecting to a Redis Cluster requires one or more initial seed nodes. The full cluster topology view (partitions) is obtained on the first connection so you&#8217;re not required to specify all cluster nodes. Specifying multiple seed nodes helps to improve resiliency as lettuce is able to connect the cluster even if a seed node is not available.
Lettuce holds multiple connections, which are opened on demand. You are free to operate on these connections.</p>
</div>
<div class="paragraph">
<p>Connections can be bound to specific hosts or nodeIds. Connections bound to a nodeId will always stick to the nodeId, even if the nodeId is handled by a different host. Requests to unknown nodeId&#8217;s or host/ports that are not part of the cluster are rejected. Do not close the connections. Otherwise, unpredictable behavior will occur.
Keep also in mind that the node connections are used by the cluster connection itself to perform cluster operations: If you block one connection all other users of the cluster connection might be affected.</p>
</div>
<div class="sect3">
<h4 id="redis-cluster.command-routing"><a class="anchor" href="#redis-cluster.command-routing"></a>5.3.1. Command routing</h4>
<div class="paragraph">
<p>The <a href="http://redis.io/topics/cluster-tutorial">concept of Redis Cluster</a> bases on sharding. Every master node within the cluster handles one or more slots. Slots are the <a href="http://redis.io/topics/cluster-tutorial#redis-cluster-data-sharding">unit of sharding</a> and calculated from the commands' key using <code>CRC16 MOD 16384</code>. Hash slots can also be specified using hash tags such as <code>{user:1000}.foo</code>.</p>
</div>
<div class="paragraph">
<p>Every request, which incorporates at least one key is routed based on its hash slot to the corresponding node. Commands without a key are executed on the <em>default</em> connection that points most likely to the first provided <code>RedisURI</code>. The same rule applies to commands operating on multiple keys but with the limitation that all keys have to be in the same slot. Commands operating on multiple slots will be terminated with a <code>CROSSSLOT</code> error.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-cluster.cross-slot-command-routing"><a class="anchor" href="#redis-cluster.cross-slot-command-routing"></a>5.3.2. Cross-slot command execution and cluster-wide execution for selected commands</h4>
<div class="paragraph">
<p>Regular Redis Cluster commands are limited to single-slot keys operation – either single key commands or multi-key commands that share the same hash slot.</p>
</div>
<div class="paragraph">
<p>The cross slot limitation can be mitigated by using the advanced cluster API for <em>a set of selected</em> multi-key commands. Commands that operate on keys with different slots are decomposed into multiple commands. The single commands are fired in a fork/join fashion. The commands are issued concurrently to avoid synchronous chaining. Results are synchronized before the command is completed.</p>
</div>
<div class="paragraph">
<p>Following commands are supported for cross-slot command execution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DEL</code>: Delete the <code>KEY</code>s. Returns the number of keys that were removed.</p>
</li>
<li>
<p><code>EXISTS</code>: Count the number of <code>KEY</code>s that exist across the master nodes being responsible for the particular key.</p>
</li>
<li>
<p><code>MGET</code>: Get the values of all given <code>KEY</code>s. Returns the values in the order of the keys.</p>
</li>
<li>
<p><code>MSET</code>: Set multiple key/value pairs for all given <code>KEY</code>s. Returns always <code>OK</code>.</p>
</li>
<li>
<p><code>TOUCH</code>: Alters the last access time of all given <code>KEY</code>s. Returns the number of keys that were touched.</p>
</li>
<li>
<p><code>UNLINK</code>: Delete the <code>KEY</code>s  and reclaiming memory in a different thread. Returns the number of keys that were removed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following commands are executed on multiple cluster nodes operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CLIENT SETNAME</code>: Set the client name on all known cluster node connections. Returns always <code>OK</code>.</p>
</li>
<li>
<p><code>KEYS</code>: Return/Stream all keys that are stored on all masters.</p>
</li>
<li>
<p><code>DBSIZE</code>: Return the number of keys that are stored on all masters.</p>
</li>
<li>
<p><code>FLUSHALL</code>: Flush all data on the cluster masters. Returns always <code>OK</code>.</p>
</li>
<li>
<p><code>FLUSHDB</code>: Flush all data on the cluster masters. Returns always <code>OK</code>.</p>
</li>
<li>
<p><code>RANDOMKEY</code>: Return a random key from a random master.</p>
</li>
<li>
<p><code>SCAN</code>: Scan the keyspace across the whole cluster according to <code>ReadFrom</code> settings.</p>
</li>
<li>
<p><code>SCRIPT FLUSH</code>: Remove all the scripts from the script cache on all cluster nodes.</p>
</li>
<li>
<p><code>SCRIPT LOAD</code>: Load the script into the Lua script cache on all nodes.</p>
</li>
<li>
<p><code>SCRIPT KILL</code>: Kill the script currently in execution on all cluster nodes. This call does not fail even if no scripts are running.</p>
</li>
<li>
<p><code>SHUTDOWN</code>: Synchronously save the dataset to disk and then shut down all nodes of the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cross-slot command execution is available on the following APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RedisAdvancedClusterCommands</code></p>
</li>
<li>
<p><code>RedisAdvancedClusterAsyncCommands</code></p>
</li>
<li>
<p><code>RedisAdvancedClusterReactiveCommands</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="redis-cluster.execution-of-commands-on-one-or-multiple-cluster-nodes"><a class="anchor" href="#redis-cluster.execution-of-commands-on-one-or-multiple-cluster-nodes"></a>5.3.3. Execution of commands on one or multiple cluster nodes</h4>
<div class="paragraph">
<p>Sometimes commands have to be executed on multiple cluster nodes. The advanced cluster API allows to select a set of nodes (e.g. all masters, all replicas) and trigger a command on this set.</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Using <code>NodeSelection</code> API to read all keys from all replicas</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisAdvancedClusterAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = clusterClient.connect().async();
AsyncNodeSelection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; replicas = connection.slaves();

AsyncExecutions&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt; executions = replicas.commands().keys(<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>);
executions.forEach(result -&gt; result.thenAccept(keys -&gt; <span class="predefined-type">System</span>.out.println(keys)));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The commands are triggered concurrently. This API is currently only available for async commands. Commands are dispatched to the nodes within the selection, the result (CompletionStage) is available through <code>AsyncExecutions</code>.</p>
</div>
<div class="paragraph">
<p>A node selection can be either dynamic or static. A dynamic node selection updates its node set upon a <a href="#user-content-refreshing-the-cluster-topology-view">cluster topology view refresh</a>. Node selections can be constructed by the following presets:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>masters</p>
</li>
<li>
<p>slaves (operate on connections with activated <code>READONLY</code> mode)</p>
</li>
<li>
<p>all nodes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A custom selection of nodes is available by implementing <a href="http://redis.paluch.biz/docs/api/current/com/lambdaworks/redis/cluster/api/async/RedisAdvancedClusterAsyncCommands.html#nodes-java.util.function.Predicate-">custom predicates</a> or lambdas.</p>
</div>
<div class="paragraph">
<p>The particular results map to a cluster node (<code>RedisClusterNode</code>) that was involved in the node selection. You can obtain the set of involved <code>RedisClusterNode</code>s and all results as <code>CompletableFuture</code> from <code>AsyncExecutions</code>.</p>
</div>
<div class="paragraph">
<p>The node selection API is a technical preview and can change at any time. That approach allows powerful operations but it requires further feedback from the users. So feel free to contribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-cluster.refreshing-the-cluster-topology-view"><a class="anchor" href="#redis-cluster.refreshing-the-cluster-topology-view"></a>5.3.4. Refreshing the cluster topology view</h4>
<div class="paragraph">
<p>The Redis Cluster configuration may change at runtime. New nodes can be added, the master for a specific slot can change. Lettuce handles <code>MOVED</code> and <code>ASK</code> redirects transparently but in case too many commands run into redirects, you should refresh the cluster topology view. The topology is bound to a <code>RedisClusterClient</code> instance. All cluster connections that are created by one <code>RedisClusterClient</code> instance share the same cluster topology view. The view can be updated in three ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Either by calling <code>RedisClusterClient.reloadPartitions</code></p>
</li>
<li>
<p><a href="#clientoptions.cluster-specific-options">Periodic updates</a> in the background based on an interval</p>
</li>
<li>
<p><a href="#clientoptions.cluster-specific-options">Adaptive updates</a> in the background based on persistent disconnects and <code>MOVED</code>/<code>ASK</code> redirections</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, commands follow <code>-ASK</code> and <code>-MOVED</code> redirects <a href="#clientoptions.cluster-specific-options">up to 5 times</a> until the command execution is considered to be failed. Background topology updating starts with the first connection obtained through <code>RedisClusterClient</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-cluster.connection-count"><a class="anchor" href="#redis-cluster.connection-count"></a>5.3.5. Connection Count for a Redis Cluster Connection Object</h4>
<div class="paragraph">
<p>With Standalone Redis, a single connection object correlates with a single transport connection. Redis Cluster works differently: A connection object with Redis Cluster consists of multiple transport connections. These are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Default connection object (Used for key-less commands and for Pub/Sub message publication)</p>
</li>
<li>
<p>Connection per node (read/write connection to communicate with individual Cluster nodes)</p>
</li>
<li>
<p>When using <code>ReadFrom</code>: Read-only connection per read replica node (read-only connection to read data from read replicas)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Connections are allocated on demand and not up-front to start with a minimal set of connections. Formula to calculate the maximum number of transport connections for a single connection object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>1 + (N * 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>N</code> is the number of cluster nodes.</p>
</div>
<div class="paragraph">
<p>Apart of connection objects, <code>RedisClusterClient</code> uses additional connections for topology refresh. These are created on topology refresh and closed after obtaining the topology:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set of connections for cluster topology refresh (a connection to each cluster node)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="redis-cluster.client-options"><a class="anchor" href="#redis-cluster.client-options"></a>5.3.6. Client-options</h4>
<div class="paragraph">
<p>See <a href="#clientoptions.cluster-specific-options">Cluster-specific Client options</a>.</p>
</div>
<div class="sect4">
<h5 id="redis-cluster.examples"><a class="anchor" href="#redis-cluster.examples"></a>Examples</h5>
<div class="exampleblock">
<div class="title">Example 35. Connecting to a Redis Cluster</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>).withPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">authentication</span><span class="delimiter">&quot;</span></span>).build();

RedisClusterClient clusterClient = RedisClusterClient.create(redisUri);
StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = clusterClient.connect();
RedisAdvancedClusterCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; syncCommands = connection.sync();

...

connection.close();
clusterClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 36. Connecting to a Redis Cluster with multiple seed nodes</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI node1 = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">node1</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>);
RedisURI node2 = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">node2</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>);

RedisClusterClient clusterClient = RedisClusterClient.create(<span class="predefined-type">Arrays</span>.asList(node1, node2));
StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = clusterClient.connect();
RedisAdvancedClusterCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; syncCommands = connection.sync();

...

connection.close();
clusterClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 37. Enabling periodic cluster topology view updates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClusterClient clusterClient = RedisClusterClient.create(RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>));

ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()
                                .enablePeriodicRefresh(<span class="integer">10</span>, <span class="predefined-type">TimeUnit</span>.MINUTES)
                                .build();

clusterClient.setOptions(ClusterClientOptions.builder()
                                .topologyRefreshOptions(topologyRefreshOptions)
                                .build());
...

clusterClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 38. Enabling adaptive cluster topology view updates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI node1 = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">node1</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>);
RedisURI node2 = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">node2</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>);

RedisClusterClient clusterClient = RedisClusterClient.create(<span class="predefined-type">Arrays</span>.asList(node1, node2));

ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()
                                .enableAdaptiveRefreshTrigger(RefreshTrigger.MOVED_REDIRECT, RefreshTrigger.PERSISTENT_RECONNECTS)
                                .adaptiveRefreshTriggersTimeout(<span class="integer">30</span>, <span class="predefined-type">TimeUnit</span>.SECONDS)
                                .build();

clusterClient.setOptions(ClusterClientOptions.builder()
                                .topologyRefreshOptions(topologyRefreshOptions)
                                .build());
...

clusterClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 39. Obtaining a node connection</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI node1 = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">node1</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>);
RedisURI node2 = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">node2</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>);

RedisClusterClient clusterClient = RedisClusterClient.create(<span class="predefined-type">Arrays</span>.asList(node1, node2));
StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = clusterClient.connect();

RedisClusterCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; node1 = connection.getConnection(<span class="string"><span class="delimiter">&quot;</span><span class="content">host</span><span class="delimiter">&quot;</span></span>, <span class="integer">7379</span>).sync();

...
<span class="comment">// do not close node1</span>

connection.close();
clusterClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="readfrom-settings"><a class="anchor" href="#readfrom-settings"></a>5.4. ReadFrom Settings</h3>
<div class="paragraph">
<p>The ReadFrom setting describes how Lettuce routes read operations to replica nodes.</p>
</div>
<div class="paragraph">
<p>By default, Lettuce routes its read operations in multi-node connections to the master node. Reading from the master returns the most recent version of the data because write operations are issued to the single master node. Reading from masters guarantees strong consistency.</p>
</div>
<div class="paragraph">
<p>You can reduce latency or improve read throughput by distributing reads to replica members for applications that do not require fully up-to-date data.</p>
</div>
<div class="paragraph">
<p>Be careful if using other ReadFrom settings than <code>MASTER</code>. Settings other than <code>MASTER</code> may return stale data because the replication is asynchronous. Data in the replicas may not hold the most recent data.</p>
</div>
<div class="sect3">
<h4 id="readfrom.redis-cluster"><a class="anchor" href="#readfrom.redis-cluster"></a>5.4.1. Redis Cluster</h4>
<div class="paragraph">
<p>Redis Cluster is a multi-node operated Redis setup that uses one or more master nodes and allows to setup replica nodes. Redis Cluster connections allow to set a <code>ReadFrom</code> setting on connection level. This setting applies for all read operations on this connection.</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. Enable Replica reads with <code>ReadFrom.REPLICA</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClusterClient client = RedisClusterClient.create(RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">host</span><span class="delimiter">&quot;</span></span>, <span class="integer">7379</span>));
StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connect();
connection.setReadFrom(ReadFrom.REPLICA);

RedisAdvancedClusterCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; sync = connection.sync();
sync.set(key, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);

sync.get(key); <span class="comment">// replica read</span>

connection.close();
client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="readfrom.masterreplica-connections"><a class="anchor" href="#readfrom.masterreplica-connections"></a>5.4.2. Master/Replica connections</h4>
<div class="paragraph">
<p>Redis nodes can be operated in a Master/Replica setup to achieve availability and performance.
Master/Replica setups can be run either Standalone or managed using Redis Sentinel. Lettuce allows to use replica nodes for read operations by using the <code>MasterReplica</code> API that supports both Master/Replica setups:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Redis Standalone Master/Replica (no failover)</p>
</li>
<li>
<p>Redis Sentinel Master/Replica (Sentinel-managed failover)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting connection uses in any case the primary connection-point to dispatch non-read operations.</p>
</div>
<div class="sect4">
<h5 id="readfrom.redis-sentinel"><a class="anchor" href="#readfrom.redis-sentinel"></a>Redis Sentinel</h5>
<div class="paragraph">
<p>Master/Replica with Redis Sentinel is very similar to regular Redis Sentinel operations. When the master fails over, a replica is promoted by Redis Sentinel to the new master and the client obtains the new topology from
Redis Sentinel.</p>
</div>
<div class="paragraph">
<p>Connections to Master/Replica require one or more Redis Sentinel connection points and a master name.
The primary connection point is the Sentinel monitored master node.</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. Using ReadFrom with Master/Replica and Redis Sentinel</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI sentinelUri = RedisURI.Builder.sentinel(<span class="string"><span class="delimiter">&quot;</span><span class="content">sentinel-host</span><span class="delimiter">&quot;</span></span>, <span class="integer">26379</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">master-name</span><span class="delimiter">&quot;</span></span>).build();
RedisClient client = RedisClient.create();

StatefulRedisMasterReplicaConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = MasterReplica.connect(
            client,
            <span class="keyword">new</span> Utf8StringCodec(),
            sentinelUri);

connection.setReadFrom(ReadFrom.REPLICA);

connection.sync().get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>); <span class="comment">// Replica read</span>

connection.close();
client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="readfrom.redis-standalone"><a class="anchor" href="#readfrom.redis-standalone"></a>Redis Standalone</h5>
<div class="paragraph">
<p>Master/Replica with Redis Standalone is very similar to regular Redis Standalone operations.
A Redis Standalone Master/Replica setup is static and provides no built-in failover. Replicas are read from the Redis Master node&#8217;s <code>INFO</code> command.</p>
</div>
<div class="paragraph">
<p>Connecting to Redis Standalone Master/Replica nodes requires connections to use the Redis Master for the <code>RedisURI</code>.
The node used within the <code>RedisURI</code> is the primary connection point.</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. Using ReadFrom with Master/Replica and Redis Standalone (Master and Replica)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI masterUri = RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">master-host</span><span class="delimiter">&quot;</span></span>, <span class="integer">6379</span>).build();
RedisClient client = RedisClient.create();

StatefulRedisMasterReplicaConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = MasterReplica.connect(
            client,
            <span class="keyword">new</span> Utf8StringCodec(),
            masterUri);

connection.setReadFrom(ReadFrom.REPLICA);

connection.sync().get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>); <span class="comment">// Replica read</span>

connection.close();
client.shutdown();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="readfrom.use-cases-for-non-master-reads"><a class="anchor" href="#readfrom.use-cases-for-non-master-reads"></a>5.4.3. Use Cases for non-master reads</h4>
<div class="paragraph">
<p>The following use cases are common for using non-master read settings and encourage eventual consistency:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Providing local reads for geographically distributed applications.
If you have Redis and application servers in multiple data centers, you may consider having a geographically distributed cluster. Using the <code>NEAREST</code> setting allows the client to read from the lowest-latency members, rather than always reading from the master node.</p>
</li>
<li>
<p>Maintaining availability during a failover.
Use <code>MASTER_PREFERRED</code> if you want an application to read from the master by default, but to allow stale reads from replicas when the master node is unavailable. <code>MASTER_PREFERRED</code> allows a "read-only mode" for your application during a failover.</p>
</li>
<li>
<p>Increase read throughput by allowing stale reads
If you want to increase your read throughput by adding additional replica nodes to your cluster
Use <code>REPLICA</code> to read explicitly from replicas and reduce read load on the master node. Using replica reads can highly lead to stale reads.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="readfrom.read-from-settings"><a class="anchor" href="#readfrom.read-from-settings"></a>5.4.4. Read from settings</h4>
<div class="paragraph">
<p>All <code>ReadFrom</code> settings except <code>MASTER</code> may return stale data because replicas replication is asynchronous and requires some delay. You need to ensure that your application can tolerate stale data.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MASTER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default mode. Read from the current master node.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MASTER_PREFERRED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read from the master, but if it is unavailable, read from replica nodes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REPLICA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read from replica nodes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REPLICA_PREFERRED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read from the replica nodes, but if none is unavailable, read from the master.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NEAREST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read from any node of the cluster with the lowest latency.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The latency of the nodes is determined upon cluster topology refresh. If the topology view is never refreshed, values from the initial cluster nodes read are used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Custom read settings can be implemented by extending the <code>io.lettuce.core.ReadFrom</code> class.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis-command-interfaces"><a class="anchor" href="#redis-command-interfaces"></a>6. Working with dynamic Redis Command Interfaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Redis Command Interface abstraction provides a dynamic way for typesafe Redis command invocation. It allows you to declare an interface with command methods to significantly reduce boilerplate code required to invoke a Redis command.</p>
</div>
<div class="sect2">
<h3 id="_introduction"><a class="anchor" href="#_introduction"></a>6.1. Introduction</h3>
<div class="paragraph">
<p>Redis is a data store supporting over 190 documented commands and over 450 command permutations. The community supports actively Redis development; each major Redis release comes with new commands. Command growth and keeping track with upcoming modules are challenging for client developers and Redis user as there is no full command coverage for each module in a single Redis client.</p>
</div>
<div class="paragraph">
<p>The central interface in lettuce Command Interface abstraction is <code>Commands</code>. This interface acts primarily as a marker interface to help you to discover interfaces that extend this one. The <code>KeyCommands</code> interface below declares some command methods.</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Command interface</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands {

    <span class="predefined-type">String</span> get(<span class="predefined-type">String</span> key);                  <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="predefined-type">String</span> set(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> value);    <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="predefined-type">String</span> set(<span class="predefined-type">String</span> key, <span class="type">byte</span><span class="type">[]</span> value);    <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieves a key by its name.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sets a key and value.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Sets a key and a value by using bytes.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The interface from above declares several methods. Let&#8217;s take a brief look at <code>String set(String key, String value)</code>. We can derive from that declaration certain things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It should be executed synchronously – there’s no <a href="#command-interfaces.asynchronous">asynchronous</a> or <a href="#command-interfaces.reactive">reactive</a> wrapper declared in the result type.</p>
</li>
<li>
<p>The Redis command method returns a <code>String</code> - that reveals something regarding the command result expectation. This command expects a reply that can be represented as <code>String</code>.</p>
</li>
<li>
<p>The method is named <code>set</code> so the derived command will be named <code>set</code>.</p>
</li>
<li>
<p>There are two parameters defined: <code>String key</code> and <code>String value</code>. Although Redis does not take any other parameter types than bulk strings, we still can apply a transformation to the parameters – we can conclude their serialization from the declared type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>set</code> command from above called would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>commands.set(&quot;key&quot;, &quot;value&quot;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command translates to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>SET key value</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_command_methods"><a class="anchor" href="#_command_methods"></a>6.2. Command methods</h3>
<div class="paragraph">
<p>With lettuce, declaring command methods becomes a four-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Declare an interface extending <code>Commands</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands { <span class="error">…</span> }</code></pre>
</div>
</div>
</li>
<li>
<p>Declare command methods on the interface.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands {
    <span class="predefined-type">String</span> get(<span class="predefined-type">String</span> key);
}</code></pre>
</div>
</div>
</li>
<li>
<p>Set up lettuce to create proxy instances for those interfaces.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = <span class="error">…</span>
RedisCommandFactory factory = <span class="keyword">new</span> RedisCommandFactory(client.connect());</code></pre>
</div>
</div>
</li>
<li>
<p>Get the commands instance and use it.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomeClient</span> {

    KeyCommands commands;

    <span class="directive">public</span> SomeClient(RedisCommandFactory factory) {
        commands = factory.getCommands(KeyCommands.class);
    }

    <span class="directive">public</span> <span class="type">void</span> doSomething() {
        <span class="predefined-type">String</span> value = commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">Walter</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The sections that follow explain each step in detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_command_methods"><a class="anchor" href="#_defining_command_methods"></a>6.3. Defining command methods</h3>
<div class="paragraph">
<p>As a first step, you define a specific command interface. The interface must extend <code>Commands</code>.</p>
</div>
<div class="paragraph">
<p>Command methods are declared inside the commands interface like regular methods (probably not that much of a surprise). Lettuce derives commands (name, arguments, and response) from each declared method.</p>
</div>
<div class="sect3">
<h4 id="_command_naming"><a class="anchor" href="#_command_naming"></a>6.3.1. Command naming</h4>
<div class="paragraph">
<p>The commands proxy has two ways to derive a Redis command from the method name. It can derive the command name from the method name directly, or by using a manually defined <code>@Command</code> annotation. However, there&#8217;s got to be a strategy that decides what actual command is created. Let&#8217;s have a look at the available options.</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. <code>MixedCommands</code> interface annotated with <code>@Command</code> and <code>@CommandNaming</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MixedCommands</span> <span class="directive">extends</span> Commands {

    <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; mget(<span class="predefined-type">String</span>... keys);                    <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">MGET</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">List</span>&lt;Value&lt;<span class="predefined-type">String</span>&gt; mgetAsValues(<span class="predefined-type">String</span>... keys);      <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="annotation">@CommandNaming</span>(strategy = DOT)
    <span class="type">double</span> nrRun(<span class="predefined-type">String</span> key, <span class="type">int</span>... indexes)              <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Plain command method. Lettuce will derive to the <code>MGET</code> command.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Command method annotated with <code>@Command</code>. Lettuce will execute <code>MGET</code> since annotations have a higher precedence than method-based name derivation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Redis commands consist of one or multiple command parts or follow a different naming strategy. The recommended pattern for commands provided by modules is using dot notation. Command methods can derive from "camel humps" that style by placing a dot (<code>.</code>) between name parts.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Command names are attempted to be resolved against <code>CommandType</code> to participate in settings for known commands. These are primarily used to determine a command intent (whether a command is a read-only one). Commands are resolved case-sensitive. Use lower-case command names in <code>@Command</code> to resolve to an unknown command to e.g. enforce master-routing.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_camelcase_in_method_names"><a class="anchor" href="#_camelcase_in_method_names"></a>6.3.2. CamelCase in method names</h4>
<div class="paragraph">
<p>Command methods use by default the method name command type. This is ideal for commands like <code>GET</code>, <code>SET</code>, <code>ZADD</code> and so on. Some commands, such as <code>CLIENT SETNAME</code> consist of multiple command segments and passing <code>SETNAME</code> as argument to a method <code>client(…)</code> feels rather clunky.</p>
</div>
<div class="paragraph">
<p>Camel case is a natural way to express word boundaries in method names. These "camel humps" (changes in letter casing) can be interpreted in different ways. The most common case is to translate a change in case into a space between command segments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">ServerCommands</span> <span class="directive">extends</span> Commands {
    <span class="predefined-type">String</span> clientSetname(<span class="predefined-type">String</span> name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Invoking <code>clientSetname(…)</code> will execute the Redis command <code>CLIENT SETNAME name</code>.</p>
</div>
<div class="sect4">
<h5 id="_commandnaming"><a class="anchor" href="#_commandnaming"></a><code>@CommandNaming</code></h5>
<div class="paragraph">
<p>Camel humps are translated to whitespace-delimited command segments by default. Methods and the commands interface can be annotated with <code>@CommandNaming</code> to apply a different strategy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CommandNaming</span>(strategy = Strategy.DOT)
<span class="type">interface</span> <span class="class">MixedCommands</span> <span class="directive">extends</span> Commands {

    <span class="annotation">@CommandNaming</span>(strategy = Strategy.SPLIT)
    <span class="predefined-type">String</span> clientSetname(<span class="predefined-type">String</span> name);

    <span class="annotation">@CommandNaming</span>(strategy = Strategy.METHOD_NAME)
    <span class="predefined-type">String</span> mSet(<span class="predefined-type">String</span> key1, <span class="predefined-type">String</span> value1, <span class="predefined-type">String</span> key2, <span class="predefined-type">String</span> value2);

    <span class="type">double</span> nrRun(<span class="predefined-type">String</span> key, <span class="type">int</span>... indexes)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can choose amongst multiple strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SPLIT</code>: Splits camel-case method names into multiple command segments: <code>clientSetname</code> executes <code>CLIENT SETNAME</code>. This is the default strategy.</p>
</li>
<li>
<p><code>METHOD_NAME</code>: Uses the method name as-is: <code>mSet</code> executes <code>MSET</code>.</p>
</li>
<li>
<p><code>DOT</code>: Translates camel-case method names into dot-notation that is the recommended pattern for module-provided commands. <code>nrRun</code> executes <code>NR.RUN</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_command_annotation"><a class="anchor" href="#_command_annotation"></a>6.3.3. <code>@Command</code> annotation</h4>
<div class="paragraph">
<p>You already learned, that method names are used as command type any by default all arguments are appended to the command. Some cases, such as the example from above, require in Java declaring a method with a different name because of variance in the return type. <code>mgetAsValues</code> would execute a non-existent command <code>MGETASVALUES</code>.</p>
</div>
<div class="paragraph">
<p>Annotating command methods with <code>@Command</code> lets you take control over implicit conventions. The annotation value overrides the command name and provides command segments to command methods. Command segments are parts of a command that are sent to Redis. The semantics of a command segment depend on context and the command itself. <code>@Command("CLIENT SETNAME")</code> denotes a subcommand of the <code>CLIENT</code> command while a method annotated with <code>@Command("SET key")</code> invokes <code>SET</code>, using <code>mykey</code> as key. <code>@Command</code> lets you specify whole command strings and reference <a href="#command-interfaces.parameters">parameters</a> to construct custom commands.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">MixedCommands</span> <span class="directive">extends</span> Commands {

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">CLIENT SETNAME</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">String</span> setName(<span class="predefined-type">String</span> name);

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">MGET</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">List</span>&lt;Value&lt;<span class="predefined-type">String</span>&gt; mgetAsValues(<span class="predefined-type">String</span>... keys);

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">SET mykey</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">String</span> set(<span class="predefined-type">String</span> value);

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">NR.OBSERVE ?0 ?1 -&gt; ?2 TRAIN</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; nrObserve(<span class="predefined-type">String</span> key, <span class="type">int</span><span class="type">[]</span> in, <span class="type">int</span>... out)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-interfaces.parameters"><a class="anchor" href="#command-interfaces.parameters"></a>6.3.4. Parameters</h4>
<div class="paragraph">
<p>Most Redis commands take one or more parameters to operate with your data. Using command methods with Redis appends all parameters in their specified order to the command as arguments. You have already seen commands annotated with <code>@Command("MGET")</code> or with no annotation at all. Commands append their parameters as command arguments as declared in the method signature.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">MixedCommands</span> <span class="directive">extends</span> Commands {

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">SET ?1 ?0</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">String</span> set(<span class="predefined-type">String</span> value, <span class="predefined-type">String</span> key);

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">NR.OBSERVE :key :in -&gt; :out TRAIN</span><span class="delimiter">&quot;</span></span>)
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; nrObserve(<span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> key, <span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">in</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span><span class="type">[]</span> in, <span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">out</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span>... out)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Command</code>-annotated command methods allow references to parameters. You can use index-based or name-based parameter references.
Index-based references (<code>?0</code>, <code>?1</code>, …) are zero-based. Name-based parameters (<code>:key</code>, <code>:in</code>) reference parameters by their name. Java 8 provides access to parameter names if the code was compiled with <code>javac -parameters</code>. Parameter names can be supplied alternatively by <code>@Param</code>. Please note that all parameters are required to be annotated if using <code>@Param</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The same parameter can be referenced multiple times. Not referenced parameters are appended as arguments after the last command segment.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="commandinterfaces.parameters.keyvalue"><a class="anchor" href="#commandinterfaces.parameters.keyvalue"></a>Keys and values</h5>
<div class="paragraph">
<p>Redis commands are usually less concerned about key and value type since all data is bytes anyway. In the context of Redis Cluster, the very first key affects command routing. Keys and values are discovered by verifying their declared type assignability to <code>RedisCodec</code> key and value types. In some cases, where keys and values are indistinguishable from their types, it might be required to hint command methods about keys and values. You can annotate key and value parameters with <code>@Key</code> and <code>@Value</code> to control which parameters should be treated as keys or values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands {

    <span class="predefined-type">String</span> set(<span class="annotation">@Key</span> <span class="predefined-type">String</span> key, <span class="annotation">@Value</span> <span class="predefined-type">String</span> value);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hinting command method parameters influences <a href="#commandinterfaces.codecs"><code>RedisCodec</code></a> selection.</p>
</div>
</div>
<div class="sect4">
<h5 id="_parameter_types"><a class="anchor" href="#_parameter_types"></a>Parameter types</h5>
<div class="paragraph">
<p>Command method parameter types are just limited by the <a href="#commandinterfaces.codecs"><code>RedisCodec</code>s</a> that are supplied to <code>RedisCommandFactory</code>. Command methods, however, support a basic set of parameter types that are agnostic to the selected codec. If a parameter is identified as key or value and the codec supports that parameter, this specific parameter is encoded by applying codec conversion.</p>
</div>
<div class="paragraph">
<p>Built-in parameter types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code> - encoded to bytes using <code>ASCII</code>.</p>
</li>
<li>
<p><code>byte[]</code></p>
</li>
<li>
<p><code>double</code>/<code>Double</code></p>
</li>
<li>
<p><code>ProtocolKeyword</code> - using its byte-representation. <code>ProtocolKeyword</code> is useful to declare/reuse commonly used Redis keywords, see <code>io.lettuce.core.protocol.CommandType</code> and <code>io.lettuce.core.protocol.CommandKeyword</code>.</p>
</li>
<li>
<p><code>Map</code> - key and value encoding of key-value pairs using <code>RedisCodec</code>.</p>
</li>
<li>
<p>types implementing <code>io.lettuce.core.CompositeParameter</code> - Lettuce comes with a set of command argument types such as <code>BitFieldArgs</code>, <code>SetArgs</code>, <code>SortArgs</code>, … that can be used as parameter. Providing <code>CompositeParameter</code> will ontribute multiple command arguments by invoking the <code>CompositeParameter.build(CommandArgs)</code> method.</p>
</li>
<li>
<p><code>Value</code>, <code>KeyValue</code>, and <code>ScoredValue</code> that are encoded to their value, key and value and score and value representation using <code>RedisCodec</code>.</p>
</li>
<li>
<p><code>GeoCoordinates</code> - contribute longitude and latitude command arguments</p>
</li>
<li>
<p><code>Limit</code> - used together with <code>ZRANGEBYLEX</code>/<code>ZRANGEBYSCORE</code> commands. Will add <code>LIMIT (offset) (count)</code> segments to the command.</p>
</li>
<li>
<p><code>Range</code> - used together with <code>ZCOUNT</code>/<code>ZRANGEBYLEX</code>/<code>ZRANGEBYSCORE</code> commands. Numerical commands are converted to numerical boundaries (<code>+inf</code>, <code>(1.0</code>, <code>[1.0</code>). Value-typed <code>Range</code> parameters are encoded to their value boundary representation (<code>+</code>, <code>-</code>, <code>[value</code>, <code>(value</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Command methods accept other, special parameter types such as <code>Timeout</code> or <code>FlushMode</code> that control <a href="#command-interfaces.execution-models">execution-model specific</a> behavior. Those parameters are filtered from command arguments.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_codecs"><a class="anchor" href="#_codecs"></a>6.3.5. Codecs</h4>
<div class="paragraph">
<p>Redis command interfaces use <code>RedisCodec</code>s for key/value encoding and decoding. Each command method performs <code>RedisCodec</code> resolution so each command method can use a different <code>RedisCodec</code>. Codec resolution is based on key and value types declared in the command method signature. Key and value parameters can be annotated with <code>@Key</code>/<code>@Value</code> annotations to hint codec resolution to the appropriate types. Codec resolution checks all annotated parameters for compatibility. If types are assignable to codec types, the codec is selected for a particular command method.</p>
</div>
<div class="paragraph">
<p>Codec resolution without annotation is based on a compatible type majority. A command method resolves to the codec accepting the most compatible types. See also <a href="#commandinterfaces.parameters.keyvalue">Keys and values</a> for details on key/value encoding. Depending on provided codecs and the command method signature it&#8217;s possible that no codec can be resolved. You need to provide either a compatible <code>RedisCodec</code> or adjust parameter types in the method signature to provide a compatible method signature. <code>RedisCommandFactory</code> uses <code>StringCodec</code> (UTF-8) and <code>ByteArrayCodec</code> by default.</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. Initialize <code>RedisCommandFactory</code> with multiple <code>RedisCodec</code>s</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisCommandFactory factory = <span class="keyword">new</span> RedisCommandFactory(connection, <span class="predefined-type">Arrays</span>.asList(<span class="keyword">new</span> ByteArrayCodec(), <span class="keyword">new</span> StringCodec(LettuceCharsets.UTF8)));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The resolved codec is also applied to command response deserialization that allows you to use parametrized command response types.</p>
</div>
</div>
<div class="sect3">
<h4 id="command-interfaces.response-types"><a class="anchor" href="#command-interfaces.response-types"></a>6.3.6. Response types</h4>
<div class="paragraph">
<p>Another aspect of command methods is their response type. Redis command responses consist of simple strings, bulk strings (byte streams) or arrays with nested elements depending on the issued command.</p>
</div>
<div class="paragraph">
<p>You can choose amongst various return types that map to a particular {custom-commands-command-output-link}. A command output can return either its return type directly (<code>List&lt;String&gt;</code> for <code>StringListOutput</code>) or stream individual elements (<code>String</code> for <code>StringListOutput</code> as it implements <code>StreamingOutput&lt;String&gt;</code>). Command output resolution depends on whether the declared return type supports streaming. The currently only supported streaming output are reactive wrappers such as <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p><code>RedisCommandFactory</code> comes with built-in command outputs that are resolved from <code>OutputRegistry</code>. You can choose from built-in command output types or register your own <code>CommandOutput</code>.</p>
</div>
<div class="paragraph">
<p>A command method can return its response directly or wrapped in a response wrapper. See <a href="#command-interfaces.execution-models">Execution models</a> for execution-specific wrapper types.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Built-in command output types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>CommandOutput</code> class</th>
<th class="tableblock halign-left valign-top">return type</th>
<th class="tableblock halign-left valign-top">streaming type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListOfMapsOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Map&lt;K, V&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArrayOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Object&gt;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DoubleOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Double</code>, <code>double</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte[]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IntegerOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Long</code>, <code>long</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KeyOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>K</code> (Codec key type)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KeyListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;K&gt;</code> (Codec key type)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>K</code>  (Codec key type)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ValueOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V</code> (Codec value type)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ValueListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;V&gt;</code> (Codec value type)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V</code>  (Codec value type)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ValueSetOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Set&lt;V&gt;</code> (Codec value type)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MapOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Map&lt;K, V&gt;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BooleanOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code>, <code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BooleanListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Boolean&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoCoordinatesListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoCoordinates</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoCoordinatesValueListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Value&lt;GeoCoordinates&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Value&lt;GeoCoordinates&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScoredValueListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;ScoredValue&lt;V&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScoredValue&lt;V&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringValueListOutput</code> (ASCII)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Value&lt;String&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Value&lt;String&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringListOutput</code> (ASCII)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;String&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ValueValueListOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Value&lt;V&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Value&lt;V&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VoidOutput</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Void</code>, <code>void</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="command-interfaces.execution-models"><a class="anchor" href="#command-interfaces.execution-models"></a>6.4. Execution models</h3>
<div class="paragraph">
<p>Each declared command methods requires a synchronization mode, more specific an execution model. Lettuce uses an event-driven command execution model to send commands, process responses, and signal completion. Command methods can execute their commands in a synchronous, <a href="#asynchronous-api">asynchronous</a> or <a href="#reactive-api">reactive</a> way.</p>
</div>
<div class="paragraph">
<p>The choice of a particular execution model is made on return type level, more specific on the return type wrapper. Each command method may use a different execution model so command methods within a command interface may mix different execution models.</p>
</div>
<div class="sect3">
<h4 id="command-interfaces.synchronous"><a class="anchor" href="#command-interfaces.synchronous"></a>6.4.1. Synchronous (Blocking) Execution</h4>
<div class="paragraph">
<p>Declaring a non-wrapped return type (like <code>List&lt;V&gt;</code>, <code>String</code>) will execute commands synchronously. See {custom-commands-command-exec-model-link} on more details on synchronous command execution.</p>
</div>
<div class="paragraph">
<p>Blocking command execution applies by default timeouts set on connection level. Command methods support timeouts on invocation level by defining a special <code>Timeout</code> parameter. The parameter position does not affect command segments since special parameters are filtered from the command arguments. Supplying <code>null</code> will apply connection defaults.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands {

    <span class="predefined-type">String</span> get(<span class="predefined-type">String</span> key, Timeout timeout);
}

KeyCommands commands = <span class="error">…</span>

commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, Timeout.create(<span class="integer">10</span>, <span class="predefined-type">TimeUnit</span>.SECONDS));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-interfaces.asynchronous"><a class="anchor" href="#command-interfaces.asynchronous"></a>6.4.2. Asynchronous (Future) Execution</h4>
<div class="paragraph">
<p>Command methods wrapping their response in <code>Future</code>, <code>CompletableFuture</code>, <code>CompletionStage</code> or <code>RedisFuture</code> will execute their commands asynchronously. Invoking an asynchronous command method will send the command to Redis at invocation time and return a return handle that allows you to synchronize or chain command execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands {

    RedisFuture&lt;<span class="predefined-type">String</span>&gt; get(<span class="predefined-type">String</span> key, Timeout timeout);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-interfaces.reactive"><a class="anchor" href="#command-interfaces.reactive"></a>6.4.3. Reactive Execution</h4>
<div class="paragraph">
<p>You can declare command methods that wrap their response in a reactive type for reactive command execution. Invoking a reactive command method will not send the command to Redis until the resulting subscriber signals demand for data to its subscription. Using reactive wrapper types allow <a href="#command-interfaces.response-types">result streaming</a> by emitting data as it&#8217;s received from the I/O channel.</p>
</div>
<div class="paragraph">
<p>Currently supported reactive types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project Reactor <code>Mono</code> and <code>Flux</code> (native)</p>
</li>
<li>
<p>RxJava 1 <code>Single</code> and <code>Observable</code> (via <code>rxjava-reactive-streams</code>)</p>
</li>
<li>
<p>RxJava 2 <code>Single</code>, <code>Maybe</code> and <code>Flowable</code> (via <code>rxjava</code> 2.0)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#reactive-api">Reactive API</a> for more details.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">KeyCommands</span> <span class="directive">extends</span> Commands {

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>)
    Mono&lt;<span class="predefined-type">String</span>&gt; get(<span class="predefined-type">String</span> key);

    <span class="annotation">@Command</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>)
    Maybe&lt;<span class="predefined-type">String</span>&gt; getRxJava2Maybe(<span class="predefined-type">String</span> key);

    Flowable&lt;<span class="predefined-type">String</span>&gt; lrange(<span class="predefined-type">String</span> key, <span class="type">long</span> start, <span class="type">long</span> stop);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-interfaces.batch"><a class="anchor" href="#command-interfaces.batch"></a>6.4.4. Batch Execution</h4>
<div class="paragraph">
<p>Command interfaces support command batching to collect multiple commands in a batch queue and flush the batch in a single write to the transport. Command batching executes commands in a deferred nature. This means that at the time of invocation no result is available. Batching can be only used with synchronous methods without a return value (<code>void</code>) or asynchronous methods returning a <code>RedisFuture</code>. Reactive command batching is not supported because reactive executed commands maintain an own subscription lifecycle that is decoupled from command method batching.</p>
</div>
<div class="paragraph">
<p>Command batching can be enabled on two levels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On class level by annotating the command interface with <code>@BatchSize</code>. All methods participate in command batching.</p>
</li>
<li>
<p>On method level by adding <code>CommandBatching</code> to the arguments. Method participates selectively in command batching.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BatchSize</span>(<span class="integer">50</span>)
<span class="type">interface</span> <span class="class">StringCommands</span> <span class="directive">extends</span> Commands {

    <span class="type">void</span> set(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> value);

    RedisFuture&lt;<span class="predefined-type">String</span>&gt; get(<span class="predefined-type">String</span> key);

    RedisFuture&lt;<span class="predefined-type">String</span>&gt; get(<span class="predefined-type">String</span> key, CommandBatching batching);
}

StringCommands commands = <span class="error">…</span>

commands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>); <span class="comment">// queued until 50 command invocations reached.</span>
                              <span class="comment">// The 50th invocation flushes the queue.</span>

commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, CommandBatching.queue()); <span class="comment">// invocation-level queueing control</span>
commands.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, CommandBatching.flush()); <span class="comment">// invocation-level queueing control,</span>
                                              <span class="comment">// flushes all queued commands</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Batching can be controlled on per invocation by passing a <code>CommandBatching</code> argument. <code>CommandBatching</code> has precedence over <code>@BatchSize</code>.</p>
</div>
<div class="paragraph">
<p>To flush queued commands at any time (without further command invocation), add <code>BatchExecutor</code> to your interface definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BatchSize</span>(<span class="integer">50</span>)
<span class="type">interface</span> <span class="class">StringCommands</span> <span class="directive">extends</span> Commands, BatchExecutor {

    RedisFuture&lt;<span class="predefined-type">String</span>&gt; get(<span class="predefined-type">String</span> key);
}

StringCommands commands = <span class="error">…</span>

commands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>);

commands.flush() <span class="comment">// force-flush</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_batch_execution_synchronization"><a class="anchor" href="#_batch_execution_synchronization"></a>Batch execution synchronization</h5>
<div class="paragraph">
<p>Queued command batches are flushed either on reaching the batch size or force flush (via <code>BatchExecutor.flush()</code> or <code>CommandBatching.flush()</code>). Errors are transported through <code>RedisFuture</code>. Synchronous commands don&#8217;t receive any result/exception signal except if the batch is flushed through a synchronous method call. Synchronous flushing throws <code>BatchException</code> containing the failed commands.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-usage"><a class="anchor" href="#advanced-usage"></a>7. Advanced usage</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="client-resources"><a class="anchor" href="#client-resources"></a>7.1. Configuring Client resources</h3>
<div class="paragraph">
<p>Client resources are configuration settings for the client related to performance, concurrency, and events. A vast part of Client resources consists of thread pools (<code>EventLoopGroup</code>s and a <code>EventExecutorGroup</code>) which build the infrastructure for the connection workers. In general, it is a good idea to reuse instances of <code>ClientResources</code> across multiple clients.</p>
</div>
<div class="paragraph">
<p>Client resources are stateful and need to be shut down if they are supplied from outside the client.</p>
</div>
<div class="sect3">
<h4 id="clientresources.creating-client-resources"><a class="anchor" href="#clientresources.creating-client-resources"></a>7.1.1. Creating Client resources</h4>
<div class="paragraph">
<p>Client resources are required to be immutable. You can create instances using two different patterns:</p>
</div>
<div class="paragraph">
<p><strong>The <code>create()</code> factory method</strong></p>
</div>
<div class="paragraph">
<p>By using the <code>create()</code> method on <code>DefaultClientResources</code> you create <code>ClientResources</code> with default settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientResources res = DefaultClientResources.create();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach fits the most needs.</p>
</div>
<div class="paragraph">
<p><strong>Resources builder</strong></p>
</div>
<div class="paragraph">
<p>You can build instances of <code>DefaultClientResources</code> by using the embedded builder. It is designed to configure the resources to your needs. The builder accepts the configuration in a fluent fashion and then creates the ClientResources at the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientResources res = DefaultClientResources.builder()
                        .ioThreadPoolSize(<span class="integer">4</span>)
                        .computationThreadPoolSize(<span class="integer">4</span>)
                        .build()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="clientresources.using-and-reusing-clientresources"><a class="anchor" href="#clientresources.using-and-reusing-clientresources"></a>7.1.2. Using and reusing <code>ClientResources</code></h4>
<div class="paragraph">
<p>A <code>RedisClient</code> and <code>RedisClusterClient</code> can be created without passing <code>ClientResources</code> upon creation. The resources are exclusive to the client and are managed itself by the client. When calling <code>shutdown()</code> of the client instance <code>ClientResources</code> are shut down.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create();
...
client.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you require multiple instances of a client or you want to provide existing thread infrastructure, you can configure a shared <code>ClientResources</code> instance using the builder. The shared Client resources can be passed upon client creation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientResources res = DefaultClientResources.create();
RedisClient client = RedisClient.create(res);
RedisClusterClient clusterClient = RedisClusterClient.create(res, seedUris);
...
client.shutdown();
clusterClient.shutdown();
res.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Shared <code>ClientResources</code> are never shut down by the client. Same applies for shared <code>EventLoopGroupProvider</code>s that are an abstraction to provide <code>EventLoopGroup</code>s.</p>
</div>
<div class="sect4">
<h5 id="clientresources.why-runtime.getruntime.availableprocessors"><a class="anchor" href="#clientresources.why-runtime.getruntime.availableprocessors"></a>Why <code>Runtime.getRuntime().availableProcessors()</code> * 3?</h5>
<div class="paragraph">
<p>Netty requires different <code>EventLoopGroup</code>s for NIO (TCP) and for EPoll (Unix Domain Socket) connections.
One additional <code>EventExecutorGroup</code> is used to perform computation tasks. <code>EventLoopGroup</code>s are started
lazily to allocate Threads on-demand.</p>
</div>
</div>
<div class="sect4">
<h5 id="clientresources.shutdown"><a class="anchor" href="#clientresources.shutdown"></a>Shutdown</h5>
<div class="paragraph">
<p>Every client instance requires a call to <code>shutdown()</code> to clear used resources. Clients with dedicated <code>ClientResources</code>
(i.e. no <code>ClientResources</code> passed within the constructor/<code>create</code>-method) will shut down <code>ClientResources</code> on their own.</p>
</div>
<div class="paragraph">
<p>Client instances with using shared <code>ClientResources</code> (i.e. <code>ClientResources</code> passed using the constructor/<code>create</code>-method)
won&#8217;t shut down the <code>ClientResources</code> on their own. The <code>ClientResources</code> instance needs to be shut down once it&#8217;s not used anymore.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="clientresources.configuration-settings"><a class="anchor" href="#clientresources.configuration-settings"></a>7.1.3. Configuration settings</h4>
<div class="paragraph">
<p>The basic configuration options are listed in the table below:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>I/O Thread Pool Size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ioThreadPoolSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Number of processors</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">The number of threads in the I/O thread pools. The number defaults to the number of available processors that the runtime returns (which, as a well-known fact, sometimes does not represent the actual number of processors). Every thread represents an internal event loop where all I/O tasks are run. The number does not reflect the actual number of I/O threads because the client requires different thread pools for Network (NIO) and Unix Domain Socket (EPoll) connections. The minimum I/O threads are <code>3</code>. A pool with fewer threads can cause undefined behavior.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Computation Thread Pool Size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>computationThreadPoolSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Number of processors</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">The number of threads in the computation thread pool. The number defaults to the number of available processors that the runtime returns (which, as a well-known fact, sometimes does not represent the actual number of processors). Every thread represents an internal event loop where all computation tasks are run. The minimum computation threads are <code>3</code>. A pool with fewer threads can cause undefined behavior.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="clientresources.advanced-settings"><a class="anchor" href="#clientresources.advanced-settings"></a>7.1.4. Advanced settings</h4>
<div class="paragraph">
<p>Values for the advanced options are listed in the table below and should not be changed unless there is a truly good reason to do so.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Provider for EventLoopGroup</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eventLoopGroupProvider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">For those who want to reuse existing netty infrastructure or the total control over the thread pools, the <code>EventLoopGroupProvider</code> API provides a way to do so. <code>EventLoopGroup</code>s are obtained and managed by an <code>EventLoopGroupProvider</code>. A provided <code>EventLoopGroupProvider</code> is not managed by the client and needs to be shut down once you do not longer need the resources.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Provided EventExecutorGroup</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eventExecutorGroup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">For those who want to reuse existing netty infrastructure or the total control over the thread pools can provide an existing <code>EventExecutorGroup</code> to the Client resources. A provided <code>EventExecutorGroup</code> is not managed by the client and needs to be shut down once you do not longer need the resources.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Event bus</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eventBus</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultEventBus</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">The event bus system is used to transport events from the client to subscribers. Events are about connection state changes, metrics, and more. Events are published using a RxJava subject and the default implementation drops events on backpressure. Learn more about the <a href="#reactive-api">Reactive API</a>. You can also publish your own events. If you wish to do so, make sure that your events implement the <code>Event</code> marker interface.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Command latency collector options</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>commandLatencyCollectorOptions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultCommandLatencyCollectorOptions</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">The client can collect latency metrics during while dispatching commands. The options allow configuring the percentiles, level of metrics (per connection or server) and whether the metrics are cumulative or reset after obtaining these. Command latency collection is enabled by default and can be disabled by setting <code>commandLatencyPublisherOptions(…)</code> to <code>DefaultEventPublisherOptions.disabled()</code>. Latency collector requires <code>LatencyUtils</code> to be on your class path.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Command latency collector</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>commandLatencyCollector</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultCommandLatencyCollector</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">The client can collect latency metrics during while dispatching commands. Command latency metrics is collected on connection or server level. Command latency collection is enabled by default and can be disabled by setting <code>commandLatencyCollectorOptions(…)</code> to <code>DefaultCommandLatencyCollectorOptions.disabled()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Latency event publisher options</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>commandLatencyPublisherOptions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultEventPublisherOptions</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Command latencies can be published using the event bus. Latency events are emitted by default every 10 minutes. Event publishing can be disabled by setting <code>commandLatencyPublisherOptions(…)</code> to <code>DefaultEventPublisherOptions.disabled()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>DNS Resolver</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dnsResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DnsResolvers.JVM_DEFAULT (or netty if present)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.5, 4.2</p>
<p class="tableblock">Configures a DNS resolver to resolve hostnames to a <code>java.net.InetAddress</code>. Defaults to the JVM DNS resolution that uses blocking hostname resolution and caching of lookup results. Users of DNS-based Redis-HA setups (e.g. AWS ElastiCache) might want to configure a different DNS resolver. Lettuce comes with <code>DirContextDnsResolver</code> that uses Java&#8217;s <code>DnsContextFactory</code> to resolve hostnames. <code>DirContextDnsResolver</code> allows using either the system DNS or custom DNS servers without caching of results so each hostname lookup yields in a DNS lookup.</p>
<p class="tableblock">Since 4.4: Defaults to <code>DnsResolvers.UNRESOLVED</code> to use netty&#8217;s <code>AddressResolver</code> that resolves DNS names on <code>Bootstrap.connect()</code> (requires netty 4.1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Reconnect Delay</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reconnectDelay</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Delay.exponential()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.2</p>
<p class="tableblock">Configures a reconnect delay used to delay reconnect attempts. Defaults to binary exponential delay with an upper boundary of <code>30 SECONDS</code>. See <code>Delay</code> for more delay implementations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Netty Customizer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NettyCustomizer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.4</p>
<p class="tableblock">Configures a netty customizer to enhance netty components. Allows customization of <code>Bootstrap</code> after <code>Bootstrap</code> configuration by Lettuce and <code>Channel</code> customization after all Lettuce handlers are added to <code>Channel</code>. The customizer allows custom SSL configuration (requires RedisURI in plain-text mode, otherwise Lettuce&#8217;s configures SSL), adding custom handlers or setting customized <code>Bootstrap</code> options. Misconfiguring <code>Bootstrap</code> or <code>Channel</code> can cause connection failures or undesired behavior.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Tracing</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tracing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>disabled</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 5.1</p>
<p class="tableblock">Configures a <code>tracing</code> instance to trace Redis calls.
Lettuce wraps Brave data models to support tracing in a vendor-agnostic way if Brave is on the class path. A Brave <code>tracing</code> instance can be created using <code>BraveTracing.create(clientTracing);</code>, where <code>clientTracing</code> is a created or existent Brave tracing instance .</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="client-options"><a class="anchor" href="#client-options"></a>7.2. Client Options</h3>
<div class="paragraph">
<p>Client options allow controlling behavior for some specific features.</p>
</div>
<div class="paragraph">
<p>Client options are immutable. Connections inherit the current options at the moment the connection is created. Changes to options will not affect existing connections.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">client.setOptions(ClientOptions.builder()
                       .autoReconnect(<span class="predefined-constant">false</span>)
                       .pingBeforeActivateConnection(<span class="predefined-constant">true</span>)
                       .build());</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PING before activating connection</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pingBeforeActivateConnection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">Enables the initial <code>PING</code> barrier before any connection is usable. If <code>true</code>, every connection and reconnect will issue a <code>PING</code> command and awaits its response before the connection is activated and enabled for use. If the check fails, the connect/reconnect is treated as a failure. Failed <code>PING</code>'s on reconnect are handled as protocol errors and can suspend reconnection if <code>suspendReconnectOnProtocolFailure</code> is enabled.</p>
<p class="tableblock">The <code>PING</code> will validate whether the other end of the connected socket is a service that behaves like a Redis server.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Auto-Reconnect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>autoReconnect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">Controls auto-reconnect behavior on connections. As soon as a connection gets closed/reset without the intention to close it, the client will try to reconnect, activate the connection and re-issue any queued commands.</p>
<p class="tableblock">This flag also has the effect that disconnected connections will refuse commands and cancel these with an exception.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cancel commands on reconnect failure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cancelCommandsOnReconnectFailure</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">If this flag is <code>true</code> any queued commands will be canceled when a reconnect fails within the activation sequence. The reconnect itself has two phases: Socket connection and protocol/connection activation. In case a connect timeout occurs, a connection reset, host lookup fails, this does not affect the cancelation of commands. In contrast, where the protocol/connection activation fails due to SSL errors or PING before activating connection failure, queued commands are canceled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Suspend reconnect on protocol failure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>suspendReconnectOnProtocolFailure</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false (was introduced in 3.1 with default true)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">If this flag is <code>true</code> the reconnect will be suspended on protocol errors. The reconnect itself has two phases: Socket connection and protocol/connection activation. In case a connect timeout occurs, a connection reset, host lookup fails, this does not affect the cancellation of commands. In contrast, where the protocol/connection activation fails due to SSL errors or PING before activating connection failure, queued commands are canceled.</p>
<p class="tableblock">Reconnection can be activated again, but there is no public API to obtain the <code>ConnectionWatchdog</code> instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Request queue size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>requestQueueSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2147483647 (<code>Integer#MAX_VALUE</code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.4, 4.1</p>
<p class="tableblock">Controls the per-connection request queue size. The command invocation will lead to a <code>RedisException</code> if the queue size is exceeded. Setting the <code>requestQueueSize</code> to a lower value will lead earlier to exceptions during overload or while the connection is in a disconnected state. A higher value means hitting the boundary will take longer to occur, but more requests will potentially be queued, and more heap space is used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disconnected behavior</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>disconnectedBehavior</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.4, 4.1</p>
<p class="tableblock">A connection can behave in a disconnected state in various ways. The auto-connect feature allows in particular to retrigger commands that have been queued while a connection is disconnected. The disconnected behavior setting allows fine-grained control over the behavior. Following settings are available:</p>
<p class="tableblock"><code>DEFAULT</code>: Accept commands when auto-reconnect is enabled, reject commands when auto-reconnect is disabled.</p>
<p class="tableblock"><code>ACCEPT_COMMANDS</code>: Accept commands in disconnected state.</p>
<p class="tableblock"><code>REJECT_COMMANDS</code>: Reject commands in disconnected state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSL Options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sslOptions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(none), use JDK defaults</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.3</p>
<p class="tableblock">Configure SSL options regarding SSL providers (JDK/OpenSSL) and key store/trust store.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Socket Options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socketOptions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10 seconds Connection-Timeout, no keep-alive, no TCP noDelay</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.3</p>
<p class="tableblock">Options to configure low-level socket options for the connections kept to Redis servers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout Options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeoutOptions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Do not timeout commands.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 5.1</p>
<p class="tableblock">Options to configure command timeouts applied to timeout commands after dispatching these (active connections, queued while disconnected, batch buffer). By default, use synchronization timeouts only on the synchronous API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Publish Reactive Signals on Scheduler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>publishOnScheduler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Use I/O thread.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 5.1.4</p>
<p class="tableblock">Use a dedicated <code>Scheduler</code> to emit reactive data signals. Enabling this option can be useful for reactive sequences that require a significant amount of processing with a single/a few Redis connections performance suffers from a single-thread-like behavior. Enabling this option uses <code>EventExecutorGroup</code> configured through <code>ClientResources</code> for data/completion signals. The used <code>Thread</code> is sticky across all signals for a single <code>Publisher</code> instance.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="clientoptions.cluster-specific-options"><a class="anchor" href="#clientoptions.cluster-specific-options"></a>7.2.1. Cluster-specific options</h4>
<div class="paragraph">
<p>Cluster client options extend the regular client options by some cluster specifics.</p>
</div>
<div class="paragraph">
<p>Cluster client options are immutable. Connections inherit the current options at the moment the connection is created. Changes to options will not affect existing connections.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()
                .enablePeriodicRefresh(refreshPeriod(<span class="integer">10</span>, <span class="predefined-type">TimeUnit</span>.MINUTES))
                .enableAllAdaptiveRefreshTriggers()
                .build();

client.setOptions(ClusterClientOptions.builder()
                       .topologyRefreshOptions(topologyRefreshOptions)
                       .build());</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Periodic cluster topology refresh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enablePeriodicRefresh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">Enables or disables periodic cluster topology refresh. The refresh is handled in the background. Partitions, the view on the Redis cluster topology, are valid for a whole <code>RedisClusterClient</code> instance, not a connection. All connections created by this client operate on the one cluster topology.</p>
<p class="tableblock">The refresh job is regularly executed, the period between the runs can be set with <code>refreshPeriod</code>. The refresh job starts after either opening the first connection with the job enabled or by calling <code>reloadPartitions</code>. The job can be disabled without discarding the full client by setting new client options.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster topology refresh period</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refreshPeriod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>60 SECONDS</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">Set the period between the refresh job runs. The effective interval cannot be changed once the refresh job is active. Changes to the value will be ignored.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adaptive cluster topology refresh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enableAdaptiveRefreshTrigger</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(none)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.2</p>
<p class="tableblock">Enables selectively adaptive topology refresh triggers. Adaptive refresh triggers initiate topology view updates based on events happened during Redis Cluster operations. Adaptive triggers lead to an immediate topology refresh. These refreshes are rate-limited using a timeout since events can happen on a large scale. Adaptive refresh triggers are disabled by default. Following triggers can be enabled:</p>
<p class="tableblock"><code>MOVED_REDIRECT</code>, <code>ASK_REDIRECT</code>, <code>PERSISTENT_RECONNECTS</code>, <code>UNKNOWN_NODE</code> (since 5.1), and <code>UNCOVERED_SLOT</code> (since 5.2) (see also reconnect attempts for the reconnect trigger)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adaptive refresh triggers timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adaptiveRefreshTriggersTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>30 SECONDS</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.2</p>
<p class="tableblock">Set the timeout between the adaptive refresh job runs. Multiple triggers within the timeout will be ignored, only the first enabled trigger leads to a topology refresh. The effective period cannot be changed once the refresh job is active. Changes to the value will be ignored.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reconnect attempts (Adaptive topology refresh trigger)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refreshTriggersReconnectAttempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.2</p>
<p class="tableblock">Set the threshold for the <code>PERSISTENT_RECONNECTS</code> refresh trigger. Topology updates based on persistent reconnects lead only to a refresh if the reconnect process tries at least the number of specified attempts. The first reconnect attempt starts with <code>1</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dynamic topology refresh sources</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dynamicRefreshSources</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 4.2</p>
<p class="tableblock">Discover cluster nodes from the topology and use only the discovered nodes as the source for the cluster topology. Using dynamic refresh will query all discovered nodes for the cluster topology details. If set to <code>false</code>, only the initial seed nodes will be used as sources for topology discovery and the number of clients will be obtained only for the initial seed nodes. This can be useful when using Redis Cluster with many nodes.</p>
<p class="tableblock">Note that enabling dynamic topology refresh sources uses node addresses reported by Redis <code>CLUSTER NODES</code> output which typically contains IP addresses.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Close stale connections</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>closeStaleConnections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.3, 4.1</p>
<p class="tableblock">Stale connections are existing connections to nodes which are no longer part of the Redis Cluster. If this flag is set to <code>true</code>, then stale connections are closed upon topology refreshes. It&#8217;s strongly advised to close stale connections as open connections will attempt to reconnect nodes if the node is no longer available and open connections require system resources.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limitation of cluster redirects</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxRedirects</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.1, 4.0</p>
<p class="tableblock">When the assignment of a slot-hash is moved in a Redis Cluster and a client requests a key that is located on the moved slot-hash, the Cluster node responds with a <code>-MOVED</code> response. In this case, the client follows the redirection and queries the cluster specified within the redirection. Under some circumstances, the redirection can be endless. To protect the client and also the Cluster, a limit of max redirects can be configured. Once the limit is reached, the <code>-MOVED</code> error is returned to the caller. This limit also applies for <code>-ASK</code> redirections in case a slot is set to <code>MIGRATING</code> state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validate cluster node membership</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validateClusterNodeMembership</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Since: 3.3, 4.0</p>
<p class="tableblock">Validate the cluster node membership before allowing connections to that node. The current implementation performs redirects using <code>MOVED</code> and <code>ASK</code> and allows obtaining connections to the particular cluster nodes. The validation was introduced during the development of version 3.3 to prevent security breaches and only allow connections to the known hosts of the <code>CLUSTER NODES</code> output.</p>
<p class="tableblock">There are some scenarios, where the strict validation is an obstruction:</p>
<p class="tableblock"><code>MOVED</code>/<code>ASK</code> redirection but the cluster topology view is stale Connecting to cluster nodes using different IP&#8217;s/hostnames (e.g. private/public IP&#8217;s)</p>
<p class="tableblock">Connecting to non-cluster members to reconfigure those while using the RedisClusterClient connection.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="clientoptions.request-queue-size-and-cluster"><a class="anchor" href="#clientoptions.request-queue-size-and-cluster"></a>7.2.2. Request queue size and cluster</h4>
<div class="paragraph">
<p>Clustered operations use multiple connections. The resulting overall-queue limit is <code>requestQueueSize * ((number of cluster nodes * 2) + 1)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ssl"><a class="anchor" href="#ssl"></a>7.3. SSL Connections</h3>
<div class="paragraph">
<p>Lettuce supports SSL connections since version 3.1 on Redis Standalone connections and since version 4.2 on Redis Cluster. Redis has no native SSL support, SSL is implemented usually by using <a href="https://www.stunnel.org/index.html">stunnel</a>.</p>
</div>
<div class="paragraph">
<p>An example stunnel configuration can look like:</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. stunnel.conf</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>cert=/etc/ssl/cert.pem
key=/etc/ssl/key.pem
capath=/etc/ssl/cert.pem
cafile=/etc/ssl/cert.pem
delay=yes
pid=/etc/ssl/stunnel.pid
foreground = no

[redis]
accept = 127.0.0.1:6443
connect = 127.0.0.1:6479</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Next step is connecting lettuce over SSL to Redis.</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. Connecting to Redis with SSL using <code>RedisURI</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>)
                                 .withSsl(<span class="predefined-constant">true</span>)
                                 .withPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">authentication</span><span class="delimiter">&quot;</span></span>)
                                 .withDatabase(<span class="integer">2</span>)
                                 .build();

RedisClient client = RedisClient.create(redisUri);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 48. Connecting to Redis with SSL using String <code>RedisURI</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">rediss://authentication@localhost/2</span><span class="delimiter">&quot;</span></span>);
RedisClient client = RedisClient.create(redisUri);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 49. Connecting to Redis Cluster with SSL using <code>RedisURI</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>)
                                 .withSsl(<span class="predefined-constant">true</span>)
                                 .withPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">authentication</span><span class="delimiter">&quot;</span></span>)
                                 .build();

RedisClusterClient client = RedisClusterClient.create(redisUri);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ssl.limitations"><a class="anchor" href="#ssl.limitations"></a>7.3.1. Limitations</h4>
<div class="paragraph">
<p>Lettuce supports SSL only on Redis Standalone and Redis Cluster connections and since 5.2, also for Master resolution using Redis Sentinel or Redis Master/Replicas.</p>
</div>
</div>
<div class="sect3">
<h4 id="ssl.connection-procedure-and-reconnect"><a class="anchor" href="#ssl.connection-procedure-and-reconnect"></a>7.3.2. Connection Procedure and Reconnect</h4>
<div class="paragraph">
<p>When connecting using SSL, lettuce performs an SSL handshake before you can use the connection. Plain text connections do not perform a handshake. Errors during the handshake throw <code>RedisConnectionException</code>s.</p>
</div>
<div class="paragraph">
<p>Reconnection behavior is also different to plain text connections. If an SSL handshake fails on reconnect (because of peer/certification verification or peer does not talk SSL) reconnection will be disabled for the connection. You will also find an error log entry within your logs.</p>
</div>
</div>
<div class="sect3">
<h4 id="ssl.certificate-chainsroot-certificateself-signed-certificates"><a class="anchor" href="#ssl.certificate-chainsroot-certificateself-signed-certificates"></a>7.3.3. Certificate Chains/Root Certificate/Self-Signed Certificates</h4>
<div class="paragraph">
<p>lettuce uses Java defaults for the trust store that is usually <code>cacerts</code> in your <code>jre/lib/security</code> directory and comes with customizable SSL options via <a href="#client-resources">Configuring Client resources</a>. If you need to add you own root certificate, so you can configure <code>SslOptions</code>, import it either to <code>cacerts</code> or you provide an own trust store and set the necessary system properties:</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. Configuring <code>SslOptions</code> via Client options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SslOptions sslOptions = SslOptions.builder()
        .jdkSslProvider()
        .truststore(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">yourtruststore.jks</span><span class="delimiter">&quot;</span></span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">changeit</span><span class="delimiter">&quot;</span></span>)
        .build();

ClientOptions clientOptions = ClientOptions.builder().sslOptions(sslOptions).build();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 51. Configuring a custom trust store via System Properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">System</span>.setProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">javax.net.ssl.trustStore</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">yourtruststore.jks</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.setProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">javax.net.ssl.trustStorePassword</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">changeit</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ssl.hostpeer-verification"><a class="anchor" href="#ssl.hostpeer-verification"></a>7.3.4. Host/Peer Verification</h4>
<div class="paragraph">
<p>By default, lettuce verifies the certificate against the validity and the common name (Name validation not supported on Java 1.6, only available on Java 1.7 and higher) of the Redis host you are connecting to. This behavior can be turned off:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = ...
redisUri.setVerifyPeer(<span class="predefined-constant">false</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(host(), sslPort())
                                 .withSsl(<span class="predefined-constant">true</span>)
                                 .withVerifyPeer(<span class="predefined-constant">false</span>)
                                 .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="starttls"><a class="anchor" href="#starttls"></a>7.3.5. StartTLS</h4>
<div class="paragraph">
<p>If you need to issue a StartTLS before you can use SSL, set the <code>startTLS</code> property of <code>RedisURI</code> to <code>true</code>. StartTLS is disabled by default.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = ...
redisUri.setStartTls(<span class="predefined-constant">true</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder.redis(host(), sslPort())
                                 .withSsl(<span class="predefined-constant">true</span>)
                                 .withStartTls(<span class="predefined-constant">true</span>)
                                 .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="native-transports"><a class="anchor" href="#native-transports"></a>7.4. Native Transports</h3>
<div class="paragraph">
<p>Netty provides two platform-specific JNI transports:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>epoll on Linux</p>
</li>
<li>
<p>kqueue on MacOS/BSD</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Lettuce defaults to native transports if the appropriate library is available within its runtime. Using a native transport adds features specific to a particular platform, generate less garbage and generally improve performance when compared to the NIO based transport. Native transports are required to connect to Redis via <a href="#unix-domain-sockets">Unix Domain Sockets</a> and are suitable for TCP connections as well.</p>
</div>
<div class="paragraph">
<p>Native transports are available with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Linux x86_64 systems with a minimum netty version of <code>4.0.26.Final</code>, requiring <code>netty-transport-native-epoll</code>, classifier <code>linux-x86_64</code></p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>io.netty<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>netty-transport-native-epoll<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>${netty-version}<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;classifier&gt;</span>linux-x86_64<span class="tag">&lt;/classifier&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>MacOS x86_64 systems with a minimum netty version of <code>4.1.11.Final</code>, requiring <code>netty-transport-native-kqueue</code>, classifier <code>osx-x86_64</code></p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>io.netty<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>netty-transport-native-kqueue<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>${netty-version}<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;classifier&gt;</span>osx-x86_64<span class="tag">&lt;/classifier&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can disable native transport use through system properties. Set <code>io.lettuce.core.epoll</code> respective <code>io.lettuce.core.kqueue</code> to <code>false</code> (default is <code>true</code>, if unset).</p>
</div>
<div class="sect3">
<h4 id="unixdomainsockets.limitations"><a class="anchor" href="#unixdomainsockets.limitations"></a>7.4.1. Limitations</h4>
<div class="paragraph">
<p>Native transport support does not work with the shaded version of lettuce because of two reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>netty-transport-native-epoll</code> and <code>netty-transport-native-kqueue</code> are not packaged into the shaded jar. So adding the jar to the classpath will resolve in different netty base classes (such as <code>io.netty.channel.EventLoopGroup</code> instead of <code>com.lambdaworks.io.netty.channel.EventLoopGroup</code>)</p>
</li>
<li>
<p>Support for using epoll/kqueue with shaded netty requires netty 4.1 and all parts of netty to be shaded.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See also Netty <a href="http://netty.io/wiki/native-transports.html">documentation on native transports</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unix-domain-sockets"><a class="anchor" href="#unix-domain-sockets"></a>7.5. Unix Domain Sockets</h3>
<div class="paragraph">
<p>Lettuce supports since version 3.2 Unix Domain Sockets for local Redis connections.</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. Connecting to Redis using RedisURI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.Builder
                             .socket(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/redis</span><span class="delimiter">&quot;</span></span>)
                             .withPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">authentication</span><span class="delimiter">&quot;</span></span>)
                             .withDatabase(<span class="integer">2</span>)
                             .build();

RedisClient client = RedisClient.create(redisUri);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 53. Connecting to Redis using String RedisURI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisURI redisUri = RedisURI.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">redis-socket:///tmp/redis</span><span class="delimiter">&quot;</span></span>);
RedisClient client = RedisClient.create(redisUri);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unix Domain Sockets are inter-process communication channels on POSIX compliant systems. They allow exchanging data between processes on the same host operating system. When using Redis, which is usually a network service, Unix Domain Sockets are usable only if connecting locally to a single instance. Redis Sentinel and Redis Cluster, maintain tables of remote or local nodes and act therefore as a registry. Unix Domain Sockets are not beneficial with Redis Sentinel and Redis Cluster.</p>
</div>
<div class="paragraph">
<p>Using <code>RedisClusterClient</code> with Unix Domain Sockets would connect to the local node using a socket and open TCP connections to all the other hosts. A good example is connecting locally to a standalone or a single cluster node
to gain performance.</p>
</div>
<div class="paragraph">
<p>See <a href="#native-transports">Native Transports</a> for more details and limitations.</p>
</div>
</div>
<div class="sect2">
<h3 id="streaming-api"><a class="anchor" href="#streaming-api"></a>7.6. Streaming API</h3>
<div class="paragraph">
<p>Redis can contain a huge set of data. Collections can burst your memory, when the amount of data is too massive for your heap.
Lettuce can return your collection data either as List/Set/Map or can push the data on <code>StreamingChannel</code> interfaces.</p>
</div>
<div class="paragraph">
<p><code>StreamingChannel</code>s are similar to callback methods. Every method, which can return bulk data (except transactions/multi and some config methods) specifies beside a regular method with a collection return class also method which accepts a <code>StreamingChannel</code>. Lettuce interacts with a <code>StreamingChannel</code> as the data arrives so data can be processed while the command is running and is not yet completed.</p>
</div>
<div class="paragraph">
<p>There are 4 StreamingChannels accepting different data types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://redis.paluch.biz/docs/api/releases/latest/com/lambdaworks/redis/output/KeyStreamingChannel.html">KeyStreamingChannel</a></p>
</li>
<li>
<p><a href="http://redis.paluch.biz/docs/api/releases/latest/com/lambdaworks/redis/output/ValueStreamingChannel.html">ValueStreamingChannel</a></p>
</li>
<li>
<p><a href="http://redis.paluch.biz/docs/api/releases/latest/com/lambdaworks/redis/output/KeyValueStreamingChannel.html">KeyValueStreamingChannel</a></p>
</li>
<li>
<p><a href="http://redis.paluch.biz/docs/api/releases/latest/com/lambdaworks/redis/output/ScoredValueStreamingChannel.html">ScoredValueStreamingChannel</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The result of the steaming methods is the count of keys/values/key-value pairs as <code>long</code> value.</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. Streaming results for <code>HGETALL</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Long</span> count = redis.hgetall(<span class="keyword">new</span> KeyValueStreamingChannel&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;()
    {
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> onKeyValue(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> value)
        {
            ...
        }
    }, key);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Streaming happens real-time to the redis responses. The method call (future) completes after the last call to the StreamingChannel.</p>
</div>
<div class="sect3">
<h4 id="streaming.examples"><a class="anchor" href="#streaming.examples"></a>7.6.1. Examples</h4>
<div class="exampleblock">
<div class="title">Example 55. ValueStreamingChannel using a Redis List</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">redis.lpush(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span>)
redis.lpush(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span>)
redis.lpush(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">three</span><span class="delimiter">&quot;</span></span>)

<span class="predefined-type">Long</span> count = redis.lrange(<span class="keyword">new</span> ValueStreamingChannel&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;()
    {
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> onValue(<span class="predefined-type">String</span> value)
        {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Value: </span><span class="delimiter">&quot;</span></span> + value);
        }
    }, <span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>,  <span class="integer">0</span>, -<span class="integer">1</span>);

<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Count: </span><span class="delimiter">&quot;</span></span> + count);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>will produce following output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Value: one
Value: two
Value: three
Count: 3</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="events"><a class="anchor" href="#events"></a>7.7. Events</h3>
<div class="sect3">
<h4 id="events.before-3.44.1"><a class="anchor" href="#events.before-3.44.1"></a>7.7.1. Before 3.4/4.1</h4>
<div class="paragraph">
<p>lettuce can notify its users of certain events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Connected</p>
</li>
<li>
<p>Disconnected</p>
</li>
<li>
<p>Exceptions in the connection handler pipeline</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can subscribe to these events using <code>RedisClient#addListener()</code> and unsubscribe with <code>RedisClient.removeListener()</code>. Both methods accept a <code>RedisConnectionStateListener</code>.</p>
</div>
<div class="paragraph">
<p><code>RedisConnectionStateListener</code> receives as connection the async implementation of the connection. This means if you use a sync way (e. g. <code>RedisConnection</code>) you will receive the <code>RedisAsyncConnectionImpl</code> instance</p>
</div>
<div class="paragraph">
<p><strong>Example</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = <span class="keyword">new</span> RedisClient(host, port);
client.addListener(<span class="keyword">new</span> RedisConnectionStateListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onRedisConnected(RedisChannelHandler&lt;?, ?&gt; connection)
    {

    }
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onRedisDisconnected(RedisChannelHandler&lt;?, ?&gt; connection)
    {

    }
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onRedisExceptionCaught(RedisChannelHandler&lt;?, ?&gt; connection, <span class="predefined-type">Throwable</span> cause)
    {

    }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="events.since-3.44.1"><a class="anchor" href="#events.since-3.44.1"></a>7.7.2. Since 3.4/4.1</h4>
<div class="paragraph">
<p>The client produces events during its operation and uses an event bus for the transport. The <code>EventBus</code> can be configured and obtained from the <a href="#client-options">Client Options</a> and is used for client- and custom events.</p>
</div>
<div class="paragraph">
<p>Following events are sent by the client:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Connection events</p>
</li>
<li>
<p>Metrics events</p>
</li>
<li>
<p>Cluster topology events</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="subscribing-to-events"><a class="anchor" href="#subscribing-to-events"></a>Subscribing to events</h5>
<div class="paragraph">
<p>The simple-most approach to subscribing to the client events is obtaining the event bus from the client&#8217;s client resources.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create()
EventBus eventBus = client.getresources().eventBus();

eventBus.get().subscribe(e -&gt; <span class="predefined-type">System</span>.out.println(event));

...
client.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calls to the <code>subscribe()</code> method will return a <code>Subscription</code>. If you plan to unsubscribe from the event stream, you can do so by calling the <code>Subscription.unsubscribe()</code> method. The event bus utilizes <a href="http://reactivex.io">RxJava</a> and the {reactive-api} to transport events from the publisher to its subscribers.</p>
</div>
<div class="paragraph">
<p>A thread of the computation thread pool (can be configured using <a href="#client-options">Client Options</a>) transports the events.</p>
</div>
</div>
<div class="sect4">
<h5 id="events.connection-events"><a class="anchor" href="#events.connection-events"></a>Connection events</h5>
<div class="paragraph">
<p>When working with events, multiple events occur. These can be used to monitor connections or react to these. Connection events transport the local and the remote connection points. The regular order of connection events is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Connected: The transport-layer connection is established (TCP or Unix Domain Socket connection established). Event type: <code>ConnectedEvent</code></p>
</li>
<li>
<p>Connection activated: The logical connection is activated and can be used to dispatch Redis commands (SSL handshake complete, PING before activating response received). Event type: <code>ConnectionActivatedEvent</code></p>
</li>
<li>
<p>Disconnected: The transport-layer connection is closed/reset. That event occurs on regular connection shutdowns and connection interruptions (outage). Event type: <code>DisconnectedEvent</code></p>
</li>
<li>
<p>Connection deactivated: The logical connection is deactivated. The internal processing state is reset and the <code>isOpen()</code> flag is set to <code>false</code> That event occurs on regular connection shutdowns and connection interruptions (outage). Event type: <code>ConnectionDeactivatedEvent</code></p>
</li>
<li>
<p>Since 5.3: Reconnect failed: A reconnect attempt failed. Contains the reconnect failure and and the retry counter. Event type: <code>ReconnectFailedEvent</code></p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="events.metrics-events"><a class="anchor" href="#events.metrics-events"></a>Metrics events</h5>
<div class="paragraph">
<p>Client command metrics is published using the event bus. The current event carries command latency metrics. Latency metrics is segregated by connection or server and command which means you can get detailed statistics on every command. Connection distinction allows seeing how particular connections perform. Server distinction how particular servers perform. You can configure metrics collection using <a href="#client-options">Client Options</a>.</p>
</div>
<div class="paragraph">
<p>In detail, two command latencies are recorded:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>RTT from dispatching the command until the first command response is processed (first response)</p>
</li>
<li>
<p>RTT from dispatching the command until the full command response is processed and at the moment the command is completed (completion)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The latency metrics provide following statistics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Number of commands</p>
</li>
<li>
<p>min latency</p>
</li>
<li>
<p>max latency</p>
</li>
<li>
<p>latency percentiles</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>First Response Latency</strong></p>
</div>
<div class="paragraph">
<p>The first response latency measuring begins at the moment the command sending begins (command flush on the netty event loop). That is not the time at when at which the command was issued from the client API. The latency time recording ends at the moment the client receives the first command bytes and starts to process the command response. Both conditions must be met to end the latency recording. The client could be busy with processing the previous command while the first bytes are already available to read. That scenario would be a good time to file an <a href="https://github.com/mp911de/lettuce/issues">issue</a> for improving the client performance. The first response latency value is good to determine the lag/network performance and can give a hint on the client and server performance.</p>
</div>
<div class="paragraph">
<p><strong>Completion Latency</strong></p>
</div>
<div class="paragraph">
<p>The completion latency begins at the same time as the first response latency but lasts until the time where the client is just about to call the <code>complete()</code> method to signal command completion. That means all command response bytes arrived and were decoded/processed, and the response data structures are ready for consumption for the user of the client. On completion callback duration (such as async or observable callbacks) are not part of the completion latency.</p>
</div>
</div>
<div class="sect4">
<h5 id="events.cluster-events"><a class="anchor" href="#events.cluster-events"></a>Cluster events</h5>
<div class="paragraph">
<p>When using Redis Cluster, you might want to know when the cluster topology changes. As soon as the cluster client discovers the cluster topology change, a <code>ClusterTopologyChangedEvent</code> event is published to the event bus. The time at which the event is published is not necessarily the time the topology change occurred. That is because the client polls the topology from the cluster.</p>
</div>
<div class="paragraph">
<p>The cluster topology changed event carries the topology view before and after the change.</p>
</div>
<div class="paragraph">
<p>Make sure, you enabled cluster topology refresh in the <a href="Client-options#cluster-topology-refresh">Client options</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pipelining_and_command_flushing"><a class="anchor" href="#_pipelining_and_command_flushing"></a>7.8. Pipelining and command flushing</h3>
<div class="paragraph">
<p>Redis is a TCP server using the client-server model and what is called a Request/Response protocol.
This means that usually a request is accomplished with the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The client sends a query to the server and reads from the socket, usually in a blocking way, for the server response.</p>
</li>
<li>
<p>The server processes the command and sends the response back to the client.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A request/response server can be implemented so that it is able to process new requests even if the client did not already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.</p>
</div>
<div class="paragraph">
<p>Using the synchronous API, in general, the program flow is blocked until the response is accomplished. The underlying connection is busy with sending the request and receiving its response. Blocking, in this case, applies only from a current Thread perspective, not from a global perspective.</p>
</div>
<div class="paragraph">
<p>To understand why using a synchronous API does not block on a global level we need to understand what this means.
Lettuce is a non-blocking and asynchronous client. It provides a synchronous API to achieve a blocking behavior on a per-Thread basis to create await (synchronize) a command response. Blocking does not affect other Threads per se. Lettuce is designed to operate in a pipelining way. Multiple threads can share one connection. While one Thread may process one command, the other Thread can send a new command. As soon as the first request returns, the first Thread&#8217;s program flow continues, while the second request is processed by Redis and comes back at a certain point in time.</p>
</div>
<div class="paragraph">
<p>Lettuce is built on top of netty decouple reading from writing and to provide thread-safe connections. The result is, that reading and writing can be handled by different threads and commands are written and read independent of each other but in sequence. You can find more details about <a href="Command-execution-reliability#message-ordering">message ordering</a> in the <a href="Command-execution-reliability#message-ordering">Wiki</a> to learn about command ordering rules in single- and multi-threaded arrangements.
The transport and command execution layer does not block the processing until a command is written, processed and while its response is read. lettuce sends commands at the moment they are invoked.</p>
</div>
<div class="paragraph">
<p>A good example is the <a href="Asynchronous-Connections">async API</a>. Every invocation on the <a href="Asynchronous-Connections">async API</a> returns a <code>Future</code> (response handle) after the command is written to the netty pipeline. A write to the pipeline does not mean, the command is written to the underlying transport. Multiple commands can be written without awaiting the response. Invocations to the API (sync, async and starting with <code>4.0</code> also reactive API) can be performed by multiple threads.</p>
</div>
<div class="paragraph">
<p>Sharing a connection between threads is possible but keep in mind:</p>
</div>
<div class="paragraph">
<p><strong>The longer commands need for processing, the longer other invoker wait for their results</strong></p>
</div>
<div class="paragraph">
<p>You should not use transactional commands (<code>MULTI</code>) on shared connection. If you use Redis-blocking commands (e. g. <code>BLPOP</code>) all invocations of the shared connection will be blocked until the blocking command returns which impacts the performance of other threads. Blocking commands can be a reason to use multiple connections.</p>
</div>
<div class="sect3">
<h4 id="pipelining.command-flushing"><a class="anchor" href="#pipelining.command-flushing"></a>7.8.1. Command flushing</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Command flushing is an advanced topic and in most cases (i.e. unless your use-case is a single-threaded mass import application) you won&#8217;t need it as Lettuce uses pipelining by default.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The normal operation mode of lettuce is to flush every command which means, that every command is written to the transport after it was issued. Any regular user desires this behavior. You can control command flushing since Version <code>3.3</code>.</p>
</div>
<div class="paragraph">
<p>Why would you want to do this? A flush is an <a href="https://github.com/netty/netty/issues/1759">expensive system call</a> and impacts performance. Batching, disabling auto-flushing, can be used under certain conditions and is recommended if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You perform multiple calls to Redis and you&#8217;re not depending immediately on the result of the call</p>
</li>
<li>
<p>You&#8217;re bulk-importing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Controlling the flush behavior is only available on the async API. The sync API emulates blocking calls and as soon as you invoke a command, you&#8217;re no longer able to interact with the connection until the blocking call ends.</p>
</div>
<div class="paragraph">
<p>The <code>AutoFlushCommands</code> state is set per connection and therefore affects all threads using the shared connection. If you want to omit this effect, use dedicated connections. The <code>AutoFlushCommands</code> state cannot be set on pooled connections by the lettuce connection pooling.</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. Asynchronous Pipelining</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connect();
RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = connection.async();

<span class="comment">// disable auto-flushing</span>
commands.setAutoFlushCommands(<span class="predefined-constant">false</span>);

<span class="comment">// perform a series of independent calls</span>
<span class="predefined-type">List</span>&lt;RedisFuture&lt;?&gt;&gt; futures = Lists.newArrayList();
<span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; iterations; i++) {
    futures.add(commands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key-</span><span class="delimiter">&quot;</span></span> + i, <span class="string"><span class="delimiter">&quot;</span><span class="content">value-</span><span class="delimiter">&quot;</span></span> + i));
    futures.add(commands.expire(<span class="string"><span class="delimiter">&quot;</span><span class="content">key-</span><span class="delimiter">&quot;</span></span> + i, <span class="integer">3600</span>));
}

<span class="comment">// write all commands to the transport layer</span>
commands.flushCommands();

<span class="comment">// synchronization example: Wait until all futures complete</span>
<span class="type">boolean</span> result = LettuceFutures.awaitAll(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.SECONDS,
                   futures.toArray(<span class="keyword">new</span> RedisFuture[futures.size()]));

<span class="comment">// later</span>
connection.close();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pipelining.performance-impact"><a class="anchor" href="#pipelining.performance-impact"></a>Performance impact</h5>
<div class="paragraph">
<p>Commands invoked in the default flush-after-write mode perform in an order of about 100Kops/sec (async/multithreaded execution). Grouping multiple commands in a batch (size depends on your environment, but batches between 50 and 1000 work nice during performance tests) can increase the throughput up to a factor of 5x.</p>
</div>
<div class="paragraph">
<p>Pipelining within the Redis docs: <a href="http://redis.io/topics/pipelining" class="bare">http://redis.io/topics/pipelining</a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_connection_pooling"><a class="anchor" href="#_connection_pooling"></a>7.9. Connection Pooling</h3>
<div class="paragraph">
<p>Lettuce connections are designed to be thread-safe so one connection can be shared amongst multiple threads and Lettuce connections <a href="#client-options">auto-reconnection</a> by default.
While connection pooling is not necessary in most cases it can be helpful in certain use cases.
Lettuce provides generic connection pooling support.</p>
</div>
<div class="sect3">
<h4 id="connection-pooling.is-connection-pooling-necessary"><a class="anchor" href="#connection-pooling.is-connection-pooling-necessary"></a>7.9.1. Is connection pooling necessary?</h4>
<div class="paragraph">
<p>Lettuce is thread-safe by design which is sufficient for most cases. All Redis user operations are executed single-threaded. Using multiple connections does not impact the performance of an application in a positive way. The use of blocking operations usually goes hand in hand with worker threads that get their dedicated connection. The use of Redis Transactions is the typical use case for dynamic connection pooling as the number of threads requiring a dedicated connection tends to be dynamic. That said, the requirement for dynamic connection pooling is limited. Connection pooling always comes with a cost of complexity and maintenance.</p>
</div>
</div>
<div class="sect3">
<h4 id="connection-pooling.modes"><a class="anchor" href="#connection-pooling.modes"></a>7.9.2. Execution Models</h4>
<div class="paragraph">
<p>Lettuce supports two execution models for pooling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Synchronous/Blocking via Apache Commons Pool 2</p>
</li>
<li>
<p>Asynchronous/Non-Blocking via a Lettuce-specific pool implementation (since version 5.1)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="connection-pooling.blocking"><a class="anchor" href="#connection-pooling.blocking"></a>7.9.3. Synchronous Connection Pooling</h4>
<div class="paragraph">
<p>Using imperative programming models, synchronous connection pooling is the right choice as it carries out all operations on the thread that is used to execute the code.</p>
</div>
<div class="sect4">
<h5 id="connection-pooling.blocking.prerequisites"><a class="anchor" href="#connection-pooling.blocking.prerequisites"></a>Prerequisites</h5>
<div class="paragraph">
<p>Lettuce requires Apache&#8217;s <a href="https://commons.apache.org/proper/commons-pool/">common-pool2</a> dependency (at least 2.2) to provide connection pooling. Make sure to include that dependency on your classpath. Otherwise, you won&#8217;t be able using connection pooling.</p>
</div>
<div class="paragraph">
<p>If using Maven, add the following dependency to your <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.apache.commons<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>commons-pool2<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>2.4.3<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="connection-pooling.blocking.connection-pool-support"><a class="anchor" href="#connection-pooling.blocking.connection-pool-support"></a>Connection pool support</h5>
<div class="paragraph">
<p>Lettuce provides generic connection pool support. It requires a connection <code>Supplier</code> that is used to create connections of any supported type (Redis Standalone, Pub/Sub, Sentinel, Master/Replica, Redis Cluster). <code>ConnectionPoolSupport</code> will create a <code>GenericObjectPool</code> or <code>SoftReferenceObjectPool</code>, depending on your needs. The pool can allocate either wrapped or direct connections.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wrapped instances will return the connection back to the pool when called <code>StatefulConnection.close()</code>.</p>
</li>
<li>
<p>Regular connections need to be returned to the pool with <code>GenericObjectPool.returnObject(…)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Basic usage</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create(RedisURI.create(host, port));

GenericObjectPool&lt;StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; pool = ConnectionPoolSupport
               .createGenericObjectPool(() -&gt; client.connect(), <span class="keyword">new</span> GenericObjectPoolConfig());

<span class="comment">// executing work</span>
<span class="keyword">try</span> (StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = pool.borrowObject()) {

    RedisCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = connection.sync();
    commands.multi();
    commands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
    commands.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value2</span><span class="delimiter">&quot;</span></span>);
    commands.exec();
}

<span class="comment">// terminating</span>
pool.close();
client.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cluster usage</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClusterClient clusterClient = RedisClusterClient.create(RedisURI.create(host, port));

GenericObjectPool&lt;StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; pool = ConnectionPoolSupport
               .createGenericObjectPool(() -&gt; clusterClient.connect(), <span class="keyword">new</span> GenericObjectPoolConfig());

<span class="comment">// execute work</span>
<span class="keyword">try</span> (StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = pool.borrowObject()) {
    connection.sync().set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
    connection.sync().blpop(<span class="integer">10</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">list</span><span class="delimiter">&quot;</span></span>);
}

<span class="comment">// terminating</span>
pool.close();
clusterClient.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connection-pooling.asynchronous.usage"><a class="anchor" href="#connection-pooling.asynchronous.usage"></a>7.9.4. Asynchronous Connection Pooling</h4>
<div class="paragraph">
<p>Asynchronous/non-blocking programming models require a non-blocking API to obtain Redis connections. A blocking connection pool can easily lead to a state that blocks the event loop and prevents your application from progress in processing.</p>
</div>
<div class="paragraph">
<p>Lettuce comes with an asynchronous, non-blocking pool implementation to be used with Lettuces asynchronous connection methods. It does not require additional dependencies.</p>
</div>
<div class="sect4">
<h5 id="connection-pooling.asynchronous.connection-pool-support"><a class="anchor" href="#connection-pooling.asynchronous.connection-pool-support"></a>Asynchronous Connection pool support</h5>
<div class="paragraph">
<p>Lettuce provides asynchronous connection pool support. It requires a connection <code>Supplier</code> that is used to asynchronously connect to any supported type (Redis Standalone, Pub/Sub, Sentinel, Master/Replica, Redis Cluster). <code>AsyncConnectionPoolSupport</code> will create a <code>BoundedAsyncPool</code>. The pool can allocate either wrapped or direct connections.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wrapped instances will return the connection back to the pool when called <code>StatefulConnection.closeAsync()</code>.</p>
</li>
<li>
<p>Regular connections need to be returned to the pool with <code>AsyncPool.release(…)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Basic usage</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClient client = RedisClient.create();

AsyncPool&lt;StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; pool = AsyncConnectionPoolSupport.createBoundedObjectPool(
        () -&gt; client.connectAsync(StringCodec.UTF8, RedisURI.create(host, port)), BoundedPoolConfig.create());

<span class="comment">// execute work</span>
CompletableFuture&lt;TransactionResult&gt; transactionResult = pool.acquire().thenCompose(connection -&gt; {

    RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = connection.async();

    async.multi();
    async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
    async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value2</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> async.exec().whenComplete((s, throwable) -&gt; pool.release(c));
});

<span class="comment">// terminating</span>
pool.closeAsync();

<span class="comment">// after pool completion</span>
client.shutdownAsync();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cluster usage</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisClusterClient clusterClient = RedisClusterClient.create(RedisURI.create(host, port));

AsyncPool&lt;StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; pool = AsyncConnectionPoolSupport.createBoundedObjectPool(
        () -&gt; clusterClient.connectAsync(StringCodec.UTF8), BoundedPoolConfig.create());

<span class="comment">// execute work</span>
CompletableFuture&lt;<span class="predefined-type">String</span>&gt; setResult = pool.acquire().thenCompose(connection -&gt; {

    RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = connection.async();

    async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> async.async.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">key2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value2</span><span class="delimiter">&quot;</span></span>).whenComplete((s, throwable) -&gt; pool.release(c));
});

<span class="comment">// terminating</span>
pool.closeAsync();

<span class="comment">// after pool completion</span>
client.shutdownAsync();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_commands"><a class="anchor" href="#_custom_commands"></a>7.10. Custom commands</h3>
<div class="paragraph">
<p>Lettuce covers nearly all Redis commands. Redis development is an ongoing process and the Redis Module system is intended to introduce new commands which are not part of the Redis Core. This requirement introduces the need to invoke custom commands or use custom outputs. Custom commands can be dispatched on the one hand using Lua and the <code>eval()</code> command, on the other side Lettuce 4.x allows you to trigger own commands. That API is used by Lettuce itself to dispatch commands and requires some knowledge of how commands are constructed and dispatched within Lettuce.</p>
</div>
<div class="paragraph">
<p>Lettuce provides two levels of command dispatching:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Using the synchronous, asynchronous or reactive API wrappers which invoke commands according to their nature</p>
</li>
<li>
<p>Using the bare connection to influence the command nature and synchronization (advanced)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Example using <code>dispatch()</code> on the synchronous API</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisCodec&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; codec = StringCodec.UTF8;
RedisCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = ...

String response = redis.dispatch(CommandType.SET, <span class="keyword">new</span> StatusOutput&lt;&gt;(codec),
                <span class="keyword">new</span> CommandArgs&lt;&gt;(codec)
                       .addKey(key)
                       .addValue(value));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example using <code>dispatch()</code> on the asynchronous API</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisCodec&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; codec = StringCodec.UTF8;
RedisAsyncCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = ...

RedisFuture&lt;<span class="predefined-type">String</span>&gt; response = redis.dispatch(CommandType.SET, <span class="keyword">new</span> StatusOutput&lt;&gt;(codec),
                                    <span class="keyword">new</span> CommandArgs&lt;&gt;(codec)
                                        .addKey(key)
                                        .addValue(value));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example using <code>dispatch()</code> on the reactive API</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisCodec&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; codec = StringCodec.UTF8;
RedisReactiveCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; commands = ...

Observable&lt;<span class="predefined-type">String</span>&gt; response = redis.dispatch(CommandType.SET, <span class="keyword">new</span> StatusOutput&lt;&gt;(codec),
                                    <span class="keyword">new</span> CommandArgs&lt;&gt;(codec)
                                        .addKey(key)
                                        .addValue(value));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example using a <code>RedisFuture</code> command wrapper</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = redis.getStatefulConnection();

RedisCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.PING,
                                        <span class="keyword">new</span> StatusOutput&lt;&gt;(<span class="keyword">new</span> Utf8StringCodec()));

AsyncCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = <span class="keyword">new</span> AsyncCommand&lt;&gt;(command);
connection.dispatch(async);

<span class="comment">// async instanceof CompletableFuture == true</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="custom-commands.mechanics-of-lettuce-commands"><a class="anchor" href="#custom-commands.mechanics-of-lettuce-commands"></a>7.10.1. Mechanics of Lettuce commands</h4>
<div class="paragraph">
<p>Lettuce uses the command pattern to implement to execute commands. Every time a command is invoked, lettuce creates a command object (<code>Command</code> or types implementing <code>RedisCommand</code>). Commands can carry arguments (<code>CommandArgs</code>) and an output (subclasses of <code>CommandOutput</code>). Both are optional. The two mandatory properties are the command type (see <code>CommandType</code> or a type implementing <code>ProtocolKeyword</code>) and a <code>RedisCodec</code>. If you dispatch commands by yourself, do not reuse command instances to dispatch commands more than once. Commands that were executed once have the completed flag set and cannot be reused.</p>
</div>
<div class="sect4">
<h5 id="custom-commands.arguments"><a class="anchor" href="#custom-commands.arguments"></a>Arguments</h5>
<div class="paragraph">
<p><code>CommandArgs</code> is a container for command arguments that follow the command keyword (<code>CommandType</code>). A <code>PING</code> or <code>QUIT</code> command do not require commands whereas the <code>GET</code> or <code>SET</code> commands require arguments in the form of keys and values.</p>
</div>
<div class="paragraph">
<p><strong>The <code>PING</code> command</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RedisCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.PING,
                                        <span class="keyword">new</span> StatusOutput&lt;&gt;(StringCodec.UTF8));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>The <code>SET</code> command</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StringCodec codec = StringCodec.UTF8;
RedisCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.SET,
                <span class="keyword">new</span> StatusOutput&lt;&gt;(codec), <span class="keyword">new</span> CommandArgs&lt;&gt;(codec)
                                                  .addKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">key</span><span class="delimiter">&quot;</span></span>)
                                                  .addValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>CommandArgs</code> allow to add one or more:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>key and arrays of keys</p>
</li>
<li>
<p>value and arrays of values</p>
</li>
<li>
<p><code>String</code>, <code>long</code> (the Redis integer), <code>double</code></p>
</li>
<li>
<p>byte array</p>
</li>
<li>
<p><code>CommandType</code>, <code>CommandKeyword</code> and generic <code>ProtocolKeyword</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The sequence of args and keywords is not validated by lettuce beyond the supported data types, meaning Redis will report errors if the command syntax is not correct.</p>
</div>
</div>
<div class="sect4">
<h5 id="custom-commands.outputs"><a class="anchor" href="#custom-commands.outputs"></a>Outputs</h5>
<div class="paragraph">
<p>Commands producing an output are required to consume the output. lettuce supports type-safe conversion of the response into the appropriate result types. The output handlers derive from the <code>CommandOutput</code> base class. lettuce provides a wide range of output types (see the <code>com.lambdaworks.redis.output</code> package for details). Command outputs are mostly used to return the result as the whole object. The response is available as soon as the whole command output is processed. There are cases, where you might want to stream the response instead of allocating a significant amount of memory and return the whole response as one. These types are called streaming outputs. Following implementations ship with lettuce:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KeyStreamingOutput</code></p>
</li>
<li>
<p><code>KeyValueScanStreamingOutput</code></p>
</li>
<li>
<p><code>KeyValueStreamingOutput</code></p>
</li>
<li>
<p><code>ScoredValueStreamingOutput</code></p>
</li>
<li>
<p><code>ValueScanStreamingOutput</code></p>
</li>
<li>
<p><code>ValueStreamingOutput</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Those outputs take a streaming channel (see <code>ValueStreamingChannel</code>) and invoke the callback method (e.g. <code>onValue(V value)</code>) for every data element.</p>
</div>
<div class="paragraph">
<p>Implementing an own output is, in general, a good idea when you want to support a different data type, or you want to work with different types than the basic collection, map, String, and primitive types. You might get an impression of the custom types idea by taking a look on <code>GeoWithinListOutput</code>, which takes a bunch of strings and nested lists to construct a list of <code>GeoWithin</code> instances.</p>
</div>
<div class="paragraph">
<p>Please note that using an output that does not fit the command output can jam the response processing and lead to not usable connections. Use either <code>ArrayOutput</code> or <code>NestedMultiOutput</code> when in doubt, so you receive a list of objects (nested lists).</p>
</div>
<div class="paragraph">
<p><strong>Output for the <code>PING</code> command</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Command&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.PING,
                                        <span class="keyword">new</span> StatusOutput&lt;&gt;(StringCodec.UTF8));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Output for the <code>HGETALL</code> command</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StringCodec codec = StringCodec.UTF8;
Command&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.HGETALL,
                                    <span class="keyword">new</span> MapOutput&lt;&gt;(codec),
                                    <span class="keyword">new</span> CommandArgs&lt;&gt;(codec).addKey(key));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Output for the <code>HKEYS</code> command</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StringCodec codec = StringCodec.UTF8;
Command&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt;&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.HKEYS,
                                    <span class="keyword">new</span> KeyListOutput&lt;&gt;(codec),
                                    <span class="keyword">new</span> CommandArgs&lt;&gt;(codec).addKey(key));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="custom-commands.synchronous-asynchronous-and-reactive"><a class="anchor" href="#custom-commands.synchronous-asynchronous-and-reactive"></a>7.10.2. Synchronous, asynchronous and reactive</h4>
<div class="paragraph">
<p>Great, that you made it up to here. You might want to know now, how to synchronize the command completion, work with <code>Future</code>s or how about the reactive API. The simple way is using the <code>dispatch(…)</code> method of the according wrapper. If this is not sufficient, then continue on reading.</p>
</div>
<div class="paragraph">
<p>The <code>dispatch()</code> method on a stateful Redis connection is not opinionated at all how you are using lettuce, whether it is synchronous or reactive. The only thing this method does is dispatching the command. The response handler handles decoding the command and completing the command once it&#8217;s done. The asynchronous command processing is the only operating mode of lettuce.</p>
</div>
<div class="paragraph">
<p>The <code>RedisCommand</code> interface provides methods to <code>complete()</code>, <code>cancel()</code> and <code>completeExceptionally()</code> the command. The <code>complete()</code> methods are called by the response handler as soon as the command is completed. Redis commands can be wrapped and augmented by that way. Wrapping is used when using transactions (<code>MULTI</code>) or Redis Cluster.</p>
</div>
<div class="paragraph">
<p>You are free to implement your command type or use one of the provided commands:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Command (default implementation)</p>
</li>
<li>
<p>AsyncCommand (the <code>CompleteableFuture</code> wrapper for <code>RedisCommand</code>)</p>
</li>
<li>
<p>CommandWrapper (generic wrapper)</p>
</li>
<li>
<p>TransactionalCommand (wraps <code>RedisCommand</code>s when <code>MULTI</code> is active)</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="custom-commands.fire-forget"><a class="anchor" href="#custom-commands.fire-forget"></a>Fire &amp; Forget</h5>
<div class="paragraph">
<p>Fire&amp;Forget is the simple-most way to dispatch commands. You just trigger it and then you do not care what happens with it, whether it completes or not, and you don&#8217;t have access to the command output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = redis.getStatefulConnection();

RedisCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.PING,
                                        <span class="keyword">new</span> StatusOutput&lt;&gt;(StringCodec.UTF8));

connection.dispatch(command);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="custom-commands.asynchronous"><a class="anchor" href="#custom-commands.asynchronous"></a>Asynchronous</h5>
<div class="paragraph">
<p>The asynchronous API works in general with the <code>AsyncCommand</code> wrapper that extends <code>CompleteableFuture</code>. <code>AsyncCommand</code> can be synchronized by <code>await()</code> or <code>get()</code> which corresponds with the asynchronous pull style. By using the methods from the <code>CompletionStage</code> interface (such as <code>handle()</code> or <code>thenAccept()</code>) the response handler will trigger the functions ("listeners") on command completion. Lear more about asynchronous usage in the <a href="#asynchronous-api">Asynchronous API</a> topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = redis.getStatefulConnection();

RedisCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.PING,
                                        <span class="keyword">new</span> StatusOutput&lt;&gt;(StringCodec.UTF8));

AsyncCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; async = <span class="keyword">new</span> AsyncCommand&lt;&gt;(command);
connection.dispatch(async);

<span class="comment">// async instanceof CompletableFuture == true</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="custom-commands.synchronous"><a class="anchor" href="#custom-commands.synchronous"></a>Synchronous</h5>
<div class="paragraph">
<p>The synchronous API of lettuce uses future synchronization to provide a synchronous view.</p>
</div>
</div>
<div class="sect4">
<h5 id="custom-commands.reactive"><a class="anchor" href="#custom-commands.reactive"></a>Reactive</h5>
<div class="paragraph">
<p>Reactive commands are dispatched at the moment of subscription (see <a href="#reactive-api">Reactive API</a> for more details on reactive APIs). In the context of Lettuce this means, you need to start before calling the <code>dispatch()</code> method. The reactive API uses internally an <code>ObservableCommand</code>, but that is internal stuff. If you want to dispatch commands the reactive way, you&#8217;ll need to wrap commands (or better: command supplier to be able to retry commands) with the <code>ReactiveCommandDispatcher</code>. The dispatcher implements the <code>OnSubscribe</code> API to create an <code>Observable&lt;T&gt;</code>, handles command dispatching at the time of subscription and can dissolve collection types to particular elements. An instance of <code>ReactiveCommandDispatcher</code> allows creating multiple <code>Observable</code>s as long as you use a <code>Supplier&lt;RedisCommand&gt;</code>. Commands that were executed once have the completed flag set and cannot be reused.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = redis.getStatefulConnection();

RedisCommand&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; command = <span class="keyword">new</span> Command&lt;&gt;(CommandType.PING,
                <span class="keyword">new</span> StatusOutput&lt;&gt;(StringCodec.UTF8));
ReactiveCommandDispatcher&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; dispatcher = <span class="keyword">new</span> ReactiveCommandDispatcher&lt;&gt;(command,
                connection, <span class="predefined-constant">false</span>);

<span class="predefined-type">Observable</span>&lt;<span class="predefined-type">String</span>&gt; observable = <span class="predefined-type">Observable</span>.create(dispatcher);
<span class="predefined-type">String</span> result = observable.toBlocking().first();

result == <span class="string"><span class="delimiter">&quot;</span><span class="content">PONG</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="command-execution-reliability"><a class="anchor" href="#command-execution-reliability"></a>7.11. Command execution reliability</h3>
<div class="paragraph">
<p>Lettuce is a thread-safe and scalable Redis client that allows multiple independent connections to Redis.</p>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.general"><a class="anchor" href="#command-execution-reliability.general"></a>7.11.1. General</h4>
<div class="paragraph">
<p>lettuce provides two levels of consistency; these are the rules for Redis command sends:</p>
</div>
<div class="paragraph">
<p>Depending on the chosen consistency level:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>at-most-once execution</strong>, i. e. no guaranteed execution</p>
</li>
<li>
<p><strong>at-least-once execution</strong>, i. e. guaranteed execution (with <a href="#exceptions-to-at-least-once">some exceptions</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Always:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>command ordering in the order of invocations</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.what-does-at-most-once-mean"><a class="anchor" href="#command-execution-reliability.what-does-at-most-once-mean"></a>7.11.2. What does <em>at-most-once</em> mean?</h4>
<div class="paragraph">
<p>When it comes to describing the semantics of an execution mechanism, there are three basic categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>at-most-once</strong> execution means that for each command handed to the mechanism, that command is execution zero or one time; in more casual terms it means that commands may be lost.</p>
</li>
<li>
<p><strong>at-least-once</strong> execution means that for each command handed to the mechanism potentially multiple attempts are made at execution it, such that at least one succeeds; again, in more casual terms this means that commands may be duplicated but not lost.</p>
</li>
<li>
<p><strong>exactly-once</strong> execution means that for each command handed to the mechanism exactly one execution is made; the command can neither be lost nor duplicated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first one is the cheapest - the highest performance, least implementation overhead - because it can be done without tracking whether the command was sent or got lost within the transport mechanism. The second one requires retries to counter transport losses, which means keeping the state at the sending end and having an acknowledgment mechanism at the receiving end. The third is most expensive—and has consequently worst performance—because also to the second it requires a state to be kept at the receiving end to filter out duplicate executions.</p>
</div>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.why-no-guaranteed-delivery"><a class="anchor" href="#command-execution-reliability.why-no-guaranteed-delivery"></a>7.11.3. Why No Guaranteed Delivery?</h4>
<div class="paragraph">
<p>At the core of the problem lies the question what exactly this guarantee shall mean:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The command is sent out on the network?</p>
</li>
<li>
<p>The command is received by the other host?</p>
</li>
<li>
<p>The command is processed by Redis?</p>
</li>
<li>
<p>The command response is sent by the other host?</p>
</li>
<li>
<p>The command response is received by the network?</p>
</li>
<li>
<p>The command response is processed successfully?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Each one of these have different challenges and costs, and it is obvious that there are conditions under which any command sending library would be unable to comply. Think for example about how a network partition would affect point three, or even what it would mean to decide upon the “successfully” part of point six.</p>
</div>
<div class="paragraph">
<p>The only meaningful way for a client to know whether an interaction was successful is by receiving a business-level acknowledgment command, which is not something lettuce could make up on its own.</p>
</div>
<div class="paragraph">
<p>lettuce allows two levels of consistency; each one has its costs and benefits, and therefore it does not try to lie and emulate a leaky abstraction.</p>
</div>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.message-ordering"><a class="anchor" href="#command-execution-reliability.message-ordering"></a>7.11.4. Message Ordering</h4>
<div class="paragraph">
<p>The rule more specifically is that commands sent are not be executed out-of-order.</p>
</div>
<div class="paragraph">
<p>The following illustrates the guarantee:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Thread <code>T1</code> sends commands <code>C1</code>, <code>C2</code>, <code>C3</code> to Redis</p>
</li>
<li>
<p>Thread <code>T2</code> sends commands <code>C4</code>, <code>C5</code>, <code>C6</code> to Redis</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This means that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>C1</code> is executed, it must be executed before <code>C2</code> and <code>C3</code>.</p>
</li>
<li>
<p>If <code>C2</code> is executed, it must be executed before <code>C3</code>.</p>
</li>
<li>
<p>If <code>C4</code> is executed, it must be executed before <code>C5</code> and <code>C6</code>.</p>
</li>
<li>
<p>If <code>C5</code> is executed, it must be executed before <code>C6</code>.</p>
</li>
<li>
<p>Redis executes commands from <code>T1</code> interleaved with commands from <code>T2</code>.</p>
</li>
<li>
<p>If there is no guaranteed delivery, any of the commands may be dropped, i.e. not arrive at Redis.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.failures-and-at-least-once-execution"><a class="anchor" href="#command-execution-reliability.failures-and-at-least-once-execution"></a>7.11.5. Failures and <em>at-least-once</em> execution</h4>
<div class="paragraph">
<p>lettuce&#8217;s <em>at-least-once</em> execution is scoped to the lifecycle of a logical connection. Redis commands are not persisted to be executed after a JVM or client restart. All Redis command state is held in memory. A retry mechanism re-executes commands that are not successfully completed if a network failure occurs. In more casual terms, when Redis is available again, the retry mechanism fires all queued commands. Commands that are issued as long as the failure persists are buffered.</p>
</div>
<div class="paragraph">
<p><em>at-least-once</em> execution ensures a higher consistency level than <em>at-most-once</em> but comes with some caveats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Commands can be executed more than once</p>
</li>
<li>
<p>Higher usage of resources since commands are buffered and sent again after reconnect</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="command-execution-reliability.exceptions-to-at-least-once"><a class="anchor" href="#command-execution-reliability.exceptions-to-at-least-once"></a>Exceptions to <em>at-least-once</em></h5>
<div class="paragraph">
<p>lettuce does not loose commands while sending them. A command execution can, however, fail for the same reasons as a normal method call can on the JVM:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StackOverflowError</code></p>
</li>
<li>
<p><code>OutOfMemoryError</code></p>
</li>
<li>
<p>other <code>Error</code>s</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also, executions can fail in specific ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The command runs into a timeout</p>
</li>
<li>
<p>The command cannot be encoded</p>
</li>
<li>
<p>The command cannot be decoded, because:</p>
</li>
<li>
<p>The output is not compatible with the command output</p>
</li>
<li>
<p>Exceptions occur while command decoding/processing. This may happen a <code>StreamingChannel</code> results in an error, or a consumer of Pub/Sub events fails while listener notification.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While the first is clearly a matter of configuration, the second deserves some thought:
The command execution does not get feedback if there was a timeout. This is in general not distinguishable from a lost message. By using the Sync API, commands that exceeded their timeout are canceled. This behavior cannot be changed. When using the Async API, users can decide, how to proceed with the command, whether the command should be canceled.</p>
</div>
<div class="paragraph">
<p>Commands which run into <code>Exception</code>s while encoding or decoding reach a non-recoverable state. Commands that cannot be <em>encoded</em> are <strong>not</strong> executed but get canceled. Commands that cannot be <em>decoded</em> were already executed; only the result is not available. These errors are caused mostly due to a wrong implementation. The result of a command, which cannot be <em>decoded</em> is that the command gets canceled, and the causing <code>Exception</code> is available in the result. The command is cleared from the response queue, and the connection stays useable.</p>
</div>
<div class="paragraph">
<p>In general, when <code>Errors</code> occur while operating on a connection, you should close the connection and use a new one. Connections, that experienced such severe failures get into a unrecoverable state, and no further response processing is possible.</p>
</div>
<div class="paragraph">
<p>Executing commands more than once</p>
</div>
<div class="paragraph">
<p>In terms of consistency, Redis commands can be grouped into two categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Idempotent commands</p>
</li>
<li>
<p>Non-idempotent commands</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Idempotent commands are commands that lead to the same state if they are executed more than once. Read commands are a good example for idempotency since they do not change the state of data. Another set of idempotent commands are commands that write a whole data structure/entry at once such as <code>SET</code>, <code>DEL</code> or <code>CLIENT SETNAME</code>. Those commands change the data to the desired state. Subsequent executions of the same command leave the data in the same state.</p>
</div>
<div class="paragraph">
<p>Non-idempotent commands change the state with every execution. This means, if you execute a command twice, each resulting state is different in comparison to the previous. Examples for non-idempotent Redis commands are such as <code>LPUSH</code>, <code>PUBLISH</code> or <code>INCR</code>.</p>
</div>
<div class="paragraph">
<p>Note: When using master-replica replication, different rules apply to <em>at-least-once</em> consistency. Replication between Redis nodes works asynchronously. A command can be processed successfully from lettuce&#8217;s client perspective, but the result is not necessarily replicated to the replica yet. If a failover occurs at that moment, a replica takes over, and the not yet replicated data is lost. Replication behavior is Redis-specific. Further documentation about failover and consistency from Redis perspective is available within the Redis docs: <a href="http://redis.io/topics/replication" class="bare">http://redis.io/topics/replication</a></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.switching-between-at-least-once-and-at-most-once-operations"><a class="anchor" href="#command-execution-reliability.switching-between-at-least-once-and-at-most-once-operations"></a>7.11.6. Switching between <em>at-least-once</em> and <em>at-most-once</em> operations</h4>
<div class="paragraph">
<p>lettuce&#8217;s consistency levels are bound to retries on reconnects and the connection state. By default, lettuce operates in the <em>at-least-once</em> mode. Auto-reconnect is enabled and as soon as the connection is re-established, queued commands are re-sent for execution. While a connection failure persists, issued commands are buffered.</p>
</div>
<div class="paragraph">
<p>To change into <em>at-most-once</em> consistency level, disable auto-reconnect mode. Connections cannot be longer reconnected and thus no retries are issued. Not successfully commands are canceled. New commands are rejected.</p>
</div>
</div>
<div class="sect3">
<h4 id="command-execution-reliability.clustered-operations"><a class="anchor" href="#command-execution-reliability.clustered-operations"></a>7.11.7. Clustered operations</h4>
<div class="paragraph">
<p>lettuce sticks in clustered operations to the same rules as for standalone operations but with one exception:</p>
</div>
<div class="paragraph">
<p>Command execution on master nodes, which is rejected by a <code>MOVED</code> response are tried to re-execute with the appropriate connection. <code>MOVED</code> errors occur on master nodes when a slot&#8217;s responsibility is moved from one cluster node to another node. Afterwards <em>at-least-once</em> and <em>at-most-once</em> rules apply.</p>
</div>
<div class="paragraph">
<p>When the cluster topology changes, generally spoken, the cluster slots or master/replica state is reconfigured, following rules apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>at-most-once</strong> If the connection is disconnected, queued commands are canceled and buffered commands, which were not sent, are executed by using the new cluster view</p>
</li>
<li>
<p><strong>at-least-once</strong> If the connection is disconnected, queued and buffered commands, which were not sent, are executed by using the new cluster view</p>
</li>
<li>
<p>If the connection is not disconnected, queued commands are finished and buffered commands, which were not sent, are executed by using the new cluster view</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integration-extension"><a class="anchor" href="#integration-extension"></a>8. Integration and Extension</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="codecs"><a class="anchor" href="#codecs"></a>8.1. Codecs</h3>
<div class="paragraph">
<p>Codecs are a pluggable mechanism for transcoding keys and values between your application and Redis. The default codec supports UTF-8 encoded String keys and values.</p>
</div>
<div class="paragraph">
<p>Each connection may have its codec passed to the extended
<code>RedisClient.connect</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;K, V&gt; connect(RedisCodec&lt;K, V&gt; codec)
StatefulRedisPubSubConnection&lt;K, V&gt; connectPubSub(RedisCodec&lt;K, V&gt; codec)</code></pre>
</div>
</div>
<div class="paragraph">
<p>lettuce ships with predefined codecs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>io.lettuce.core.codec.ByteArrayCodec</code> - use <code>byte[]</code> for keys and values</p>
</li>
<li>
<p><code>io.lettuce.core.codec.StringCodec</code> - use Strings for keys and values. Using the default charset or a specified <code>Charset</code> with improved support for <code>US_ASCII</code> and <code>UTF-8</code>.</p>
</li>
<li>
<p><code>io.lettuce.core.codec.CipherCodec</code> - used for transparent encryption of values.</p>
</li>
<li>
<p><code>io.lettuce.core.codec.CompressionCodec</code> - apply <code>GZIP</code> or <code>DEFLATE</code> compression to values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Publish/Subscribe connections use channel names and patterns for keys; messages are treated as values.</p>
</div>
<div class="paragraph">
<p>Keys and values can be encoded independently from each other which means the key can be a <code>java.lang.String</code> while the value is a <code>byte[]</code>. Many other constellations are possible like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Representing your data as JSON if your data is mapped to a particular Java type. Different types are hard to map since the codec applies to all operations.</p>
</li>
<li>
<p>Serialize your data using the Java Serializer (<code>ObjectInputStream</code>/<code>ObjectOutputStream</code>). Allows type-safe conversions but is less interoperable with other languages</p>
</li>
<li>
<p>Serializing your data using <a href="https://github.com/EsotericSoftware/kryo">Kryo</a> for improved type-safe serialization.</p>
</li>
<li>
<p>Any specialized codecs like the <code>BitStringCodec</code> (see below)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="codecs.why-bytebuffer-instead-of-byte"><a class="anchor" href="#codecs.why-bytebuffer-instead-of-byte"></a>8.1.1. Why <code>ByteBuffer</code> instead of <code>byte[]</code></h4>
<div class="paragraph">
<p>The <code>RedisCodec</code> interface accepts and returns <code>ByteBuffer</code>s for data interchange. A <code>ByteBuffer</code> is not opinionated about the source of the underlying bytes. The <code>byte[]</code> interface of lettuce 3.x required the user to provide an array with the exact data for interchange. So if you have an array where you want to use only a subset, you&#8217;re required to create a new instance of a byte array and copy the data. The same applies if you have a different byte source (e.g. netty&#8217;s <code>ByteBuf</code> or an NIO <code>ByteBuffer</code>). The <code>ByteBuffer</code>s for decoding are pointers to the underlying data. <code>ByteBuffer</code>s for encoding data can be either pure pointers or allocated memory. lettuce does not free any memory (such as pooled buffers).</p>
</div>
</div>
<div class="sect3">
<h4 id="codecs.diversity-in-codecs"><a class="anchor" href="#codecs.diversity-in-codecs"></a>8.1.2. Diversity in Codecs</h4>
<div class="paragraph">
<p>As in every other segment of technology, there is no one-fits-it-all solution when it comes to Codecs. Redis data structures provide a variety of
The key and value limitation of codecs is intentionally and a balance amongst convenience and simplicity. The Redis API allows much more variance in encoding and decoding particular data elements. A good example is Redis hashes. A hash is identified by its key but stores another key/value pairs. The keys of the key-value pairs could be encoded using a different approach than the key of the hash. Another different approach might be to use different encodings between lists and sets. Using a base codec (such as UTF-8 or byte array) and performing an own conversion on top of the base codec is often the better idea.</p>
</div>
</div>
<div class="sect3">
<h4 id="codecs.multi-threading"><a class="anchor" href="#codecs.multi-threading"></a>8.1.3. Multi-Threading</h4>
<div class="paragraph">
<p>A key point in Codecs is that Codecs are shared resources and can be used by multiple threads. Your
Codec needs to be thread-safe (by shared-nothing, pooling or synchronization). Every logical lettuce connection uses its codec instance. Codec instances are shared as soon as multiple threads are issuing commands or if you use Redis Cluster.</p>
</div>
</div>
<div class="sect3">
<h4 id="codecs.compression"><a class="anchor" href="#codecs.compression"></a>8.1.4. Compression</h4>
<div class="paragraph">
<p>Compression can be a good idea when storing larger chunks of data within Redis. Any textual data structures (such as JSON or XML) are suited for compression. Compression is handled at Codec-level which means you do not have to change your application to apply compression. The <code>CompressionCodec</code> provides basic and transparent compression for values using either GZIP or Deflate compression:</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. Compression Codec usage</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; connection = client.connect(
                CompressionCodec.valueCompressor(<span class="keyword">new</span> SerializedObjectCodec(), CompressionCodec.CompressionType.GZIP)).sync();

StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connect(
                CompressionCodec.valueCompressor(StringCodec.UTF8, CompressionCodec.CompressionType.DEFLATE)).sync();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Compression can be used with any codec, the compressor just wraps the inner <code>RedisCodec</code> and compresses/decompresses the data that is interchanged. You can build your own compressor the same way as you can provide own codecs.</p>
</div>
</div>
<div class="sect3">
<h4 id="codecs.examples"><a class="anchor" href="#codecs.examples"></a>8.1.5. Examples</h4>
<div class="exampleblock">
<div class="title">Example 58. BitString codec</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BitStringCodec</span> <span class="directive">extends</span> StringCodec {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> decodeValue(<span class="predefined-type">ByteBuffer</span> bytes) {
        <span class="predefined-type">StringBuilder</span> bits = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>(bytes.remaining() * <span class="integer">8</span>);
        <span class="keyword">while</span> (bytes.remaining() &gt; <span class="integer">0</span>) {
            <span class="type">byte</span> b = bytes.get();
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; <span class="integer">8</span>; i++) {
                bits.append(<span class="predefined-type">Integer</span>.valueOf(b &gt;&gt;&gt; i &amp; <span class="integer">1</span>));
            }
        }
        <span class="keyword">return</span> bits.toString();
    }
}

StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection = client.connect(<span class="keyword">new</span> BitStringCodec());
RedisCommands&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; redis = connection.sync();

redis.setbit(key, <span class="integer">0</span>, <span class="integer">1</span>);
redis.setbit(key, <span class="integer">1</span>, <span class="integer">1</span>);
redis.setbit(key, <span class="integer">2</span>, <span class="integer">0</span>);
redis.setbit(key, <span class="integer">3</span>, <span class="integer">0</span>);
redis.setbit(key, <span class="integer">4</span>, <span class="integer">0</span>);
redis.setbit(key, <span class="integer">5</span>, <span class="integer">1</span>);

redis.get(key) == <span class="string"><span class="delimiter">&quot;</span><span class="content">00100011</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 59. JDK Serializer</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SerializedObjectCodec</span> <span class="directive">implements</span> RedisCodec&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; {
    <span class="directive">private</span> <span class="predefined-type">Charset</span> charset = <span class="predefined-type">Charset</span>.forName(<span class="string"><span class="delimiter">&quot;</span><span class="content">UTF-8</span><span class="delimiter">&quot;</span></span>);

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> decodeKey(<span class="predefined-type">ByteBuffer</span> bytes) {
        <span class="keyword">return</span> charset.decode(bytes).toString();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Object</span> decodeValue(<span class="predefined-type">ByteBuffer</span> bytes) {
        <span class="keyword">try</span> {
            <span class="type">byte</span><span class="type">[]</span> array = <span class="keyword">new</span> <span class="type">byte</span>[bytes.remaining()];
            bytes.get(array);
            <span class="predefined-type">ObjectInputStream</span> is = <span class="keyword">new</span> <span class="predefined-type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="predefined-type">ByteArrayInputStream</span>(array));
            <span class="keyword">return</span> is.readObject();
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">ByteBuffer</span> encodeKey(<span class="predefined-type">String</span> key) {
        <span class="keyword">return</span> charset.encode(key);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">ByteBuffer</span> encodeValue(<span class="predefined-type">Object</span> value) {
        <span class="keyword">try</span> {
            <span class="predefined-type">ByteArrayOutputStream</span> bytes = <span class="keyword">new</span> <span class="predefined-type">ByteArrayOutputStream</span>();
            <span class="predefined-type">ObjectOutputStream</span> os = <span class="keyword">new</span> <span class="predefined-type">ObjectOutputStream</span>(bytes);
            os.writeObject(value);
            <span class="keyword">return</span> <span class="predefined-type">ByteBuffer</span>.wrap(bytes.toByteArray());
        } <span class="keyword">catch</span> (<span class="exception">IOException</span> e) {
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cdi-support"><a class="anchor" href="#cdi-support"></a>8.2. CDI Support</h3>
<div class="paragraph">
<p>CDI support for Lettuce is available for <code>RedisClient</code> and <code>RedisClusterClient</code>. You need to provide a <code>RedisURI</code> in order to get lettuce injected.</p>
</div>
<div class="sect3">
<h4 id="redisuri-producer"><a class="anchor" href="#redisuri-producer"></a>8.2.1. RedisURI producer</h4>
<div class="paragraph">
<p>Implement a simple producer (either field producer or producer method) of <code>RedisURI</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>
<span class="directive">public</span> RedisURI redisURI() {
    <span class="keyword">return</span> RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>).build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>lettuce also supports qualified <code>RedisURI</code>'s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>
<span class="annotation">@PersonDB</span>
<span class="directive">public</span> RedisURI redisURI() {
    <span class="keyword">return</span> RedisURI.Builder.redis(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>).build();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injection"><a class="anchor" href="#injection"></a>8.2.2. Injection</h4>
<div class="paragraph">
<p>After declaring your <code>RedisURI</code>'s you can start using lettuce in your classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">InjectedClient</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> RedisClient redisClient;

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> RedisClusterClient redisClusterClient;

    <span class="annotation">@Inject</span>
    <span class="annotation">@PersonDB</span>
    <span class="directive">private</span> RedisClient redisClient;

    <span class="directive">private</span> RedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection;

    <span class="annotation">@PostConstruct</span>
    <span class="directive">public</span> <span class="type">void</span> postConstruct() {
        connection = redisClient.connect();
    }

    <span class="directive">public</span> <span class="type">void</span> pingRedis() {
        connection.ping();
    }

    <span class="annotation">@PreDestroy</span>
    <span class="directive">public</span> <span class="type">void</span> preDestroy() {
        <span class="keyword">if</span> (connection != <span class="predefined-constant">null</span>) {
            connection.close();
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="activating-lettuces-cdi-extension"><a class="anchor" href="#activating-lettuces-cdi-extension"></a>8.2.3. Activating Lettuce&#8217;s CDI extension</h4>
<div class="paragraph">
<p>By default, you just drop lettuce on your classpath and declare at least one <code>RedisURI</code> bean. That&#8217;s all.</p>
</div>
<div class="paragraph">
<p>The CDI extension registers one bean pair (<code>RedisClient</code> and <code>RedisClusterClient</code>) per discovered <code>RedisURI</code>. This means,
if you do not declare any <code>RedisURI</code> producers, the CDI extension won&#8217;t be activated at all. This way you can use
lettuce in CDI-capable containers without even activating the CDI extension.</p>
</div>
<div class="paragraph">
<p>All produced beans (<code>RedisClient</code> and <code>RedisClusterClient</code>) remain active as long as your application is running since the beans are <code>@ApplicationScoped</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-support"><a class="anchor" href="#spring-support"></a>8.3. Spring Support</h3>
<div class="paragraph">
<p>Use Lettuce with Spring to manage the <code>RedisClient</code> and the <code>RedisClusterClient</code>.
You need to specify a <code>RedisURI</code> or a URI string in order to create the client.</p>
</div>
<div class="paragraph">
<p>You can integrate with Lettuce either by using <a href="https://github.com/spring-projects/spring-data-redis/">Spring Data Redis</a> (recommended) or standalone by providing Java/XML configuration.</p>
</div>
<div class="sect3">
<h4 id="spring.spring-data-redis"><a class="anchor" href="#spring.spring-data-redis"></a>8.3.1. Spring Data Redis</h4>
<div class="paragraph">
<p>Using Lettuce through <a href="http://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis</a> provides familiar Spring abstractions for Redis usage. It integrates well with other Spring components such as Spring Session or Spring Boot. See Spring Data Redis <a href="http://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis:connectors:lettuce">reference documentation</a> for lettuce usage.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring.redis-client"><a class="anchor" href="#spring.redis-client"></a>8.3.2. Redis Client</h4>
<div class="paragraph">
<p>Lettuce Standalone/Sentinel/Pub/Sub and Master/Replica can be used through <code>RedisClient</code>. You can provide bean definitions to manage Lettuce resources inside a Spring context. Bean management can take care of resource allocation and clean up through Spring&#8217;s bean lifecycle management. Using managed beans gives you the possibility to access lettuce&#8217;s <code>RedisClient</code>/connections from various places inside your code. Your code can also benefit from dependency injection.</p>
</div>
<div class="sect4">
<h5 id="spring.redis-client.java-configuration"><a class="anchor" href="#spring.redis-client.java-configuration"></a>Java Configuration</h5>
<div class="paragraph">
<p>Configuring lettuce using Spring&#8217;s Java Configuration with <code>@Bean</code> definitions requires you to provide bean definitions. Notice the specification of <code>destroyMethod</code> to clean up resources once the application context is shut down.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LettuceConfig</span> {

    <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">shutdown</span><span class="delimiter">&quot;</span></span>)
    ClientResources clientResources() {
        <span class="keyword">return</span> DefaultClientResources.create();
    }

    <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">shutdown</span><span class="delimiter">&quot;</span></span>)
    RedisClient redisClient(ClientResources clientResources) {

        <span class="keyword">return</span> RedisClient.create(clientResources, RedisURI.create(TestSettings.host(), TestSettings.port()));
    }

    <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>)
    StatefulRedisConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; connection(RedisClient redisClient) {
        <span class="keyword">return</span> redisClient.connect();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring.redis-client.xml-configuration"><a class="anchor" href="#spring.redis-client.xml-configuration"></a>XML Configuration</h5>
<div class="paragraph">
<p>Use <code>RedisClientFactoryBean</code> to create a managed instance of <code>RedisClient</code> using XML-based configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">redisClient</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">io.lettuce.core.support.RedisClientFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mypassword</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="comment">&lt;!-- Redis URI Format: redis://host[:port]/database --&gt;</span>
    <span class="comment">&lt;!-- Redis URI: Specify Database as Path --&gt;</span>
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">uri</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://localhost/12</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

    <span class="comment">&lt;!-- Redis Sentinel URI Format: redis-sentinel://host[:port][,host[:port][,host[:port]]/database#masterId --&gt;</span>
    <span class="comment">&lt;!-- Redis Sentinel URI: You can specify multiple sentinels. Specify Database as Path, Master Id as Fragment. --&gt;</span>
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">uri</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">redis-sentinel://localhost,localhost2,localhost3/1#myMaster</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring.redis-cluster-client"><a class="anchor" href="#spring.redis-cluster-client"></a>8.3.3. Redis Cluster Client</h4>
<div class="paragraph">
<p>Lettuce Redis Cluster support can be used through <code>RedisClusterClient</code>. You can provide bean definitions to manage Lettuce resources inside a Spring context. Bean management can take care of resource allocation and clean up through Spring&#8217;s bean lifecycle management. Using managed beans gives you the possibility to access Lettuce&#8217;s <code>RedisClusterClient</code>/connections from various places inside your code. Your code can also benefit from dependency injection.</p>
</div>
<div class="sect4">
<h5 id="spring.redis-cluster-client.java-configuration"><a class="anchor" href="#spring.redis-cluster-client.java-configuration"></a>Java Configuration</h5>
<div class="paragraph">
<p>Configuring Lettuce using Spring&#8217;s Java Configuration with <code>@Bean</code> definitions requires you to provide bean definitions. Notice the specification of <code>destroyMethod</code> to clean up resources once the application context is shut down.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LettuceConfig</span> {

    <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">shutdown</span><span class="delimiter">&quot;</span></span>)
    ClientResources clientResources() {
        <span class="keyword">return</span> DefaultClientResources.create();
    }

    <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">shutdown</span><span class="delimiter">&quot;</span></span>)
    RedisClusterClient redisClusterClient(ClientResources clientResources) {

        RedisURI redisURI = RedisURI.create(TestSettings.host(), <span class="integer">7379</span>);

        <span class="keyword">return</span> RedisClusterClient.create(clientResources, redisURI);
    }

    <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>)
    StatefulRedisClusterConnection&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; clusterConnection(RedisClusterClient clusterClient) {
        <span class="keyword">return</span> clusterClient.connect();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring.redis-cluster-client.xml-configuration"><a class="anchor" href="#spring.redis-cluster-client.xml-configuration"></a>XML Configuration</h5>
<div class="paragraph">
<p>Use <code>RedisClusterClientFactoryBean</code> to create a managed instance of <code>RedisClusterClient</code> using XML-based configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">redisClient</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">io.lettuce.core.support.RedisClusterClientFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mypassword</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="comment">&lt;!-- Redis URI Format: redis://host[:port]/database --&gt;</span>
    <span class="comment">&lt;!-- Redis URI: Specify Database as Path --&gt;</span>
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">uri</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">redis://localhost/12</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-11 11:45:11 +0100
</div>
</div>
<link rel="stylesheet" href="stylesheets/coderay-asciidoctor.css">
</body>
</html>